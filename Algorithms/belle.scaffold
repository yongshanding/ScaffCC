// Scaffold file synthesized by para-bench.py
// qubits: 16 ancilla: 8 gates: 8 levels: 4 degrees: 3 loops: 32
#include "qalloc.h"
#include "uncompute.h"
#define LOOP 32
// Call list: 1,2,3;4,5,6;7,8;;9,10;11,12,13;14;;15;16;17,18,19;;20,21,22;23,24;25,26;27,28;
// Function 28 with degree 0
// nq: 6, na: 4, ng: 6
void func28(qbit **q, int n) {
printf("func28\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[5];
	nb[0] = q[4];
	nb[1] = q[4];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[5];
	nb[5] = q[3];
	nb[6] = q[3];
	nb[7] = q[1];
	nb[8] = q[4];
	res[0] = q[0];
	res[1] = q[3];
	res[2] = q[4];
	res[3] = q[5];
	res[4] = q[2];
	// Leaf function
	Compute (0, 4, 17, 11, 0, 2, 0) {
		acquire(4, anc, 9, nb);
		Toffoli( anc[2], q[4], anc[0] );
		CNOT( anc[2], anc[1] );
		Toffoli( q[4], anc[3], q[1] );
		Toffoli( anc[2], q[0], q[5] );
		CNOT( q[3], anc[0] );
		Toffoli( q[3], q[1], q[4] );
	}
	Store {
		CNOT( q[5], res[0] );
		CNOT( q[0], res[1] );
		CNOT( anc[2], res[2] );
		CNOT( q[2], res[3] );
		CNOT( q[4], res[4] );
	}
	Uncompute(res, 0, anc, 4, 17, 11){
		Toffoli( q[3], q[1], q[4] );
		CNOT( q[3], anc[0] );
		Toffoli( anc[2], q[0], q[5] );
		Toffoli( q[4], anc[3], q[1] );
		CNOT( anc[2], anc[1] );
		Toffoli( anc[2], q[4], anc[0] );
	} Free(anc, 4) {}
}
// Function 28 with degree 0
// nq: 6, na: 4, ng: 6
void func28R(qbit **q, int n) {
printf("func28R\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[5];
	nb[0] = q[4];
	nb[1] = q[4];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[5];
	nb[5] = q[3];
	nb[6] = q[3];
	nb[7] = q[1];
	nb[8] = q[4];
	res[0] = q[0];
	res[1] = q[3];
	res[2] = q[4];
	res[3] = q[5];
	res[4] = q[2];
	// Leaf function
	_computeModule(0, 4, 17, 11, 0, 2, 0);
	acquire(4, anc, 9, nb);
	Recompute (res, 0, anc, 4, 17, 11){
		Toffoli( q[3], q[1], q[4] );
		CNOT( q[3], anc[0] );
		Toffoli( anc[2], q[0], q[5] );
		Toffoli( q[4], anc[3], q[1] );
		CNOT( anc[2], anc[1] );
		Toffoli( anc[2], q[4], anc[0] );
	}
	Restore {
		CNOT( q[5], res[0] );
		CNOT( q[0], res[1] );
		CNOT( anc[2], res[2] );
		CNOT( q[2], res[3] );
		CNOT( q[4], res[4] );
	}
	Unrecompute {
		Toffoli( anc[2], q[4], anc[0] );
		CNOT( anc[2], anc[1] );
		Toffoli( q[4], anc[3], q[1] );
		Toffoli( anc[2], q[0], q[5] );
		CNOT( q[3], anc[0] );
		Toffoli( q[3], q[1], q[4] );
	} Refree(anc, 4) {}
}
// Function 27 with degree 0
// nq: 6, na: 7, ng: 2
void func27(qbit **q, int n) {
printf("func27\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[1]; // interacting bits
	qbit *res[5];
	nb[0] = q[2];
	res[0] = q[4];
	res[1] = q[5];
	res[2] = q[1];
	res[3] = q[2];
	res[4] = q[0];
	// Leaf function
	Compute (0, 7, 9, 7, 0, 2, 0) {
		acquire(7, anc, 1, nb);
		Toffoli( q[2], anc[1], anc[3] );
		Toffoli( anc[6], anc[5], anc[4] );
	}
	Store {
		CNOT( anc[0], res[0] );
		CNOT( q[2], res[1] );
		CNOT( anc[6], res[2] );
		CNOT( anc[2], res[3] );
		CNOT( q[4], res[4] );
	}
	Uncompute(res, 0, anc, 7, 9, 7){
		Toffoli( anc[6], anc[5], anc[4] );
		Toffoli( q[2], anc[1], anc[3] );
	} Free(anc, 7) {}
}
// Function 27 with degree 0
// nq: 6, na: 7, ng: 2
void func27R(qbit **q, int n) {
printf("func27R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[1]; // interacting bits
	qbit *res[5];
	nb[0] = q[2];
	res[0] = q[4];
	res[1] = q[5];
	res[2] = q[1];
	res[3] = q[2];
	res[4] = q[0];
	// Leaf function
	_computeModule(0, 7, 9, 7, 0, 2, 0);
	acquire(7, anc, 1, nb);
	Recompute (res, 0, anc, 7, 9, 7){
		Toffoli( anc[6], anc[5], anc[4] );
		Toffoli( q[2], anc[1], anc[3] );
	}
	Restore {
		CNOT( anc[0], res[0] );
		CNOT( q[2], res[1] );
		CNOT( anc[6], res[2] );
		CNOT( anc[2], res[3] );
		CNOT( q[4], res[4] );
	}
	Unrecompute {
		Toffoli( q[2], anc[1], anc[3] );
		Toffoli( anc[6], anc[5], anc[4] );
	} Refree(anc, 7) {}
}
// Function 26 with degree 0
// nq: 4, na: 6, ng: 8
void func26(qbit **q, int n) {
printf("func26\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[7]; // interacting bits
	qbit *res[2];
	nb[0] = q[3];
	nb[1] = q[3];
	nb[2] = q[2];
	nb[3] = q[3];
	nb[4] = q[3];
	nb[5] = q[3];
	nb[6] = q[3];
	res[0] = q[3];
	res[1] = q[2];
	// Leaf function
	Compute (0, 6, 18, 10, 0, 2, 0) {
		acquire(6, anc, 7, nb);
		CNOT( anc[0], q[3] );
		CNOT( q[3], anc[0] );
		Toffoli( anc[4], q[2], anc[1] );
		Toffoli( anc[3], anc[4], anc[1] );
		Toffoli( anc[1], anc[5], q[3] );
		CNOT( q[3], anc[3] );
		CNOT( anc[2], q[3] );
		Toffoli( anc[0], anc[3], q[3] );
	}
	Store {
		CNOT( q[2], res[0] );
		CNOT( anc[4], res[1] );
	}
	Uncompute(res, 0, anc, 6, 18, 10){
		Toffoli( anc[0], anc[3], q[3] );
		CNOT( anc[2], q[3] );
		CNOT( q[3], anc[3] );
		Toffoli( anc[1], anc[5], q[3] );
		Toffoli( anc[3], anc[4], anc[1] );
		Toffoli( anc[4], q[2], anc[1] );
		CNOT( q[3], anc[0] );
		CNOT( anc[0], q[3] );
	} Free(anc, 6) {}
}
// Function 26 with degree 0
// nq: 4, na: 6, ng: 8
void func26R(qbit **q, int n) {
printf("func26R\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[7]; // interacting bits
	qbit *res[2];
	nb[0] = q[3];
	nb[1] = q[3];
	nb[2] = q[2];
	nb[3] = q[3];
	nb[4] = q[3];
	nb[5] = q[3];
	nb[6] = q[3];
	res[0] = q[3];
	res[1] = q[2];
	// Leaf function
	_computeModule(0, 6, 18, 10, 0, 2, 0);
	acquire(6, anc, 7, nb);
	Recompute (res, 0, anc, 6, 18, 10){
		Toffoli( anc[0], anc[3], q[3] );
		CNOT( anc[2], q[3] );
		CNOT( q[3], anc[3] );
		Toffoli( anc[1], anc[5], q[3] );
		Toffoli( anc[3], anc[4], anc[1] );
		Toffoli( anc[4], q[2], anc[1] );
		CNOT( q[3], anc[0] );
		CNOT( anc[0], q[3] );
	}
	Restore {
		CNOT( q[2], res[0] );
		CNOT( anc[4], res[1] );
	}
	Unrecompute {
		CNOT( anc[0], q[3] );
		CNOT( q[3], anc[0] );
		Toffoli( anc[4], q[2], anc[1] );
		Toffoli( anc[3], anc[4], anc[1] );
		Toffoli( anc[1], anc[5], q[3] );
		CNOT( q[3], anc[3] );
		CNOT( anc[2], q[3] );
		Toffoli( anc[0], anc[3], q[3] );
	} Refree(anc, 6) {}
}
// Function 25 with degree 0
// nq: 4, na: 6, ng: 8
void func25(qbit **q, int n) {
printf("func25\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[8]; // interacting bits
	qbit *res[1];
	nb[0] = q[1];
	nb[1] = q[3];
	nb[2] = q[3];
	nb[3] = q[2];
	nb[4] = q[1];
	nb[5] = q[0];
	nb[6] = q[0];
	nb[7] = q[0];
	res[0] = q[3];
	// Leaf function
	Compute (0, 6, 17, 9, 0, 2, 0) {
		acquire(6, anc, 8, nb);
		CNOT( anc[4], q[1] );
		Toffoli( anc[1], q[3], anc[5] );
		CNOT( anc[0], q[3] );
		CNOT( anc[0], q[2] );
		CNOT( anc[1], anc[3] );
		CNOT( q[1], q[0] );
		CNOT( anc[4], q[0] );
		Toffoli( q[0], anc[2], anc[0] );
	}
	Store {
		CNOT( q[1], res[0] );
	}
	Uncompute(res, 0, anc, 6, 17, 9){
		Toffoli( q[0], anc[2], anc[0] );
		CNOT( anc[4], q[0] );
		CNOT( q[1], q[0] );
		CNOT( anc[1], anc[3] );
		CNOT( anc[0], q[2] );
		CNOT( anc[0], q[3] );
		Toffoli( anc[1], q[3], anc[5] );
		CNOT( anc[4], q[1] );
	} Free(anc, 6) {}
}
// Function 25 with degree 0
// nq: 4, na: 6, ng: 8
void func25R(qbit **q, int n) {
printf("func25R\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[8]; // interacting bits
	qbit *res[1];
	nb[0] = q[1];
	nb[1] = q[3];
	nb[2] = q[3];
	nb[3] = q[2];
	nb[4] = q[1];
	nb[5] = q[0];
	nb[6] = q[0];
	nb[7] = q[0];
	res[0] = q[3];
	// Leaf function
	_computeModule(0, 6, 17, 9, 0, 2, 0);
	acquire(6, anc, 8, nb);
	Recompute (res, 0, anc, 6, 17, 9){
		Toffoli( q[0], anc[2], anc[0] );
		CNOT( anc[4], q[0] );
		CNOT( q[1], q[0] );
		CNOT( anc[1], anc[3] );
		CNOT( anc[0], q[2] );
		CNOT( anc[0], q[3] );
		Toffoli( anc[1], q[3], anc[5] );
		CNOT( anc[4], q[1] );
	}
	Restore {
		CNOT( q[1], res[0] );
	}
	Unrecompute {
		CNOT( anc[4], q[1] );
		Toffoli( anc[1], q[3], anc[5] );
		CNOT( anc[0], q[3] );
		CNOT( anc[0], q[2] );
		CNOT( anc[1], anc[3] );
		CNOT( q[1], q[0] );
		CNOT( anc[4], q[0] );
		Toffoli( q[0], anc[2], anc[0] );
	} Refree(anc, 6) {}
}
// Function 24 with degree 0
// nq: 2, na: 7, ng: 4
void func24(qbit **q, int n) {
printf("func24\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[2];
	nb[0] = q[1];
	nb[1] = q[0];
	res[0] = q[1];
	res[1] = q[0];
	// Leaf function
	Compute (0, 7, 10, 6, 0, 2, 0) {
		acquire(7, anc, 2, nb);
		Toffoli( anc[6], anc[5], anc[2] );
		CNOT( q[1], anc[4] );
		Toffoli( anc[3], q[0], anc[2] );
		CNOT( anc[0], anc[2] );
	}
	Store {
		CNOT( anc[0], res[0] );
		CNOT( anc[3], res[1] );
	}
	Uncompute(res, 0, anc, 7, 10, 6){
		CNOT( anc[0], anc[2] );
		Toffoli( anc[3], q[0], anc[2] );
		CNOT( q[1], anc[4] );
		Toffoli( anc[6], anc[5], anc[2] );
	} Free(anc, 7) {}
}
// Function 24 with degree 0
// nq: 2, na: 7, ng: 4
void func24R(qbit **q, int n) {
printf("func24R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[2];
	nb[0] = q[1];
	nb[1] = q[0];
	res[0] = q[1];
	res[1] = q[0];
	// Leaf function
	_computeModule(0, 7, 10, 6, 0, 2, 0);
	acquire(7, anc, 2, nb);
	Recompute (res, 0, anc, 7, 10, 6){
		CNOT( anc[0], anc[2] );
		Toffoli( anc[3], q[0], anc[2] );
		CNOT( q[1], anc[4] );
		Toffoli( anc[6], anc[5], anc[2] );
	}
	Restore {
		CNOT( anc[0], res[0] );
		CNOT( anc[3], res[1] );
	}
	Unrecompute {
		Toffoli( anc[6], anc[5], anc[2] );
		CNOT( q[1], anc[4] );
		Toffoli( anc[3], q[0], anc[2] );
		CNOT( anc[0], anc[2] );
	} Refree(anc, 7) {}
}
// Function 23 with degree 0
// nq: 2, na: 2, ng: 7
void func23(qbit **q, int n) {
printf("func23\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[10]; // interacting bits
	qbit *res[2];
	nb[0] = q[1];
	nb[1] = q[1];
	nb[2] = q[0];
	nb[3] = q[1];
	nb[4] = q[1];
	nb[5] = q[1];
	nb[6] = q[1];
	nb[7] = q[0];
	nb[8] = q[0];
	nb[9] = q[1];
	res[0] = q[0];
	res[1] = q[1];
	// Leaf function
	Compute (0, 2, 16, 9, 0, 2, 0) {
		acquire(2, anc, 10, nb);
		CNOT( q[1], anc[0] );
		Toffoli( anc[1], q[1], anc[0] );
		CNOT( q[0], q[1] );
		CNOT( anc[1], q[1] );
		CNOT( q[1], anc[0] );
		Toffoli( anc[0], q[1], q[0] );
		Toffoli( anc[1], q[0], q[1] );
	}
	Store {
		CNOT( anc[0], res[0] );
		CNOT( anc[1], res[1] );
	}
	Uncompute(res, 0, anc, 2, 16, 9){
		Toffoli( anc[1], q[0], q[1] );
		Toffoli( anc[0], q[1], q[0] );
		CNOT( q[1], anc[0] );
		CNOT( anc[1], q[1] );
		CNOT( q[0], q[1] );
		Toffoli( anc[1], q[1], anc[0] );
		CNOT( q[1], anc[0] );
	} Free(anc, 2) {}
}
// Function 23 with degree 0
// nq: 2, na: 2, ng: 7
void func23R(qbit **q, int n) {
printf("func23R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[10]; // interacting bits
	qbit *res[2];
	nb[0] = q[1];
	nb[1] = q[1];
	nb[2] = q[0];
	nb[3] = q[1];
	nb[4] = q[1];
	nb[5] = q[1];
	nb[6] = q[1];
	nb[7] = q[0];
	nb[8] = q[0];
	nb[9] = q[1];
	res[0] = q[0];
	res[1] = q[1];
	// Leaf function
	_computeModule(0, 2, 16, 9, 0, 2, 0);
	acquire(2, anc, 10, nb);
	Recompute (res, 0, anc, 2, 16, 9){
		Toffoli( anc[1], q[0], q[1] );
		Toffoli( anc[0], q[1], q[0] );
		CNOT( q[1], anc[0] );
		CNOT( anc[1], q[1] );
		CNOT( q[0], q[1] );
		Toffoli( anc[1], q[1], anc[0] );
		CNOT( q[1], anc[0] );
	}
	Restore {
		CNOT( anc[0], res[0] );
		CNOT( anc[1], res[1] );
	}
	Unrecompute {
		CNOT( q[1], anc[0] );
		Toffoli( anc[1], q[1], anc[0] );
		CNOT( q[0], q[1] );
		CNOT( anc[1], q[1] );
		CNOT( q[1], anc[0] );
		Toffoli( anc[0], q[1], q[0] );
		Toffoli( anc[1], q[0], q[1] );
	} Refree(anc, 2) {}
}
// Function 22 with degree 0
// nq: 1, na: 7, ng: 2
void func22(qbit **q, int n) {
printf("func22\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	nb[1] = q[0];
	res[0] = q[0];
	// Leaf function
	Compute (0, 7, 5, 3, 0, 3, 0) {
		acquire(7, anc, 2, nb);
		Toffoli( anc[2], q[0], anc[6] );
		CNOT( anc[0], q[0] );
	}
	Store {
		CNOT( anc[2], res[0] );
	}
	Uncompute(res, 0, anc, 7, 5, 3){
		CNOT( anc[0], q[0] );
		Toffoli( anc[2], q[0], anc[6] );
	} Free(anc, 7) {}
}
// Function 22 with degree 0
// nq: 1, na: 7, ng: 2
void func22R(qbit **q, int n) {
printf("func22R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	nb[1] = q[0];
	res[0] = q[0];
	// Leaf function
	_computeModule(0, 7, 5, 3, 0, 3, 0);
	acquire(7, anc, 2, nb);
	Recompute (res, 0, anc, 7, 5, 3){
		CNOT( anc[0], q[0] );
		Toffoli( anc[2], q[0], anc[6] );
	}
	Restore {
		CNOT( anc[2], res[0] );
	}
	Unrecompute {
		Toffoli( anc[2], q[0], anc[6] );
		CNOT( anc[0], q[0] );
	} Refree(anc, 7) {}
}
// Function 21 with degree 0
// nq: 1, na: 2, ng: 6
void func21(qbit **q, int n) {
printf("func21\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	nb[1] = q[0];
	nb[2] = q[0];
	nb[3] = q[0];
	nb[4] = q[0];
	nb[5] = q[0];
	res[0] = q[0];
	// Leaf function
	Compute (0, 2, 13, 7, 0, 3, 0) {
		acquire(2, anc, 6, nb);
		CNOT( anc[1], q[0] );
		Toffoli( anc[1], anc[0], q[0] );
		Toffoli( anc[0], anc[1], q[0] );
		CNOT( q[0], anc[1] );
		Toffoli( q[0], anc[1], anc[0] );
		Toffoli( q[0], anc[1], anc[0] );
	}
	Store {
		CNOT( anc[0], res[0] );
	}
	Uncompute(res, 0, anc, 2, 13, 7){
		Toffoli( q[0], anc[1], anc[0] );
		Toffoli( q[0], anc[1], anc[0] );
		CNOT( q[0], anc[1] );
		Toffoli( anc[0], anc[1], q[0] );
		Toffoli( anc[1], anc[0], q[0] );
		CNOT( anc[1], q[0] );
	} Free(anc, 2) {}
}
// Function 21 with degree 0
// nq: 1, na: 2, ng: 6
void func21R(qbit **q, int n) {
printf("func21R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	nb[1] = q[0];
	nb[2] = q[0];
	nb[3] = q[0];
	nb[4] = q[0];
	nb[5] = q[0];
	res[0] = q[0];
	// Leaf function
	_computeModule(0, 2, 13, 7, 0, 3, 0);
	acquire(2, anc, 6, nb);
	Recompute (res, 0, anc, 2, 13, 7){
		Toffoli( q[0], anc[1], anc[0] );
		Toffoli( q[0], anc[1], anc[0] );
		CNOT( q[0], anc[1] );
		Toffoli( anc[0], anc[1], q[0] );
		Toffoli( anc[1], anc[0], q[0] );
		CNOT( anc[1], q[0] );
	}
	Restore {
		CNOT( anc[0], res[0] );
	}
	Unrecompute {
		CNOT( anc[1], q[0] );
		Toffoli( anc[1], anc[0], q[0] );
		Toffoli( anc[0], anc[1], q[0] );
		CNOT( q[0], anc[1] );
		Toffoli( q[0], anc[1], anc[0] );
		Toffoli( q[0], anc[1], anc[0] );
	} Refree(anc, 2) {}
}
// Function 20 with degree 0
// nq: 1, na: 2, ng: 5
void func20(qbit **q, int n) {
printf("func20\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[4]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	nb[1] = q[0];
	nb[2] = q[0];
	nb[3] = q[0];
	res[0] = q[0];
	// Leaf function
	Compute (0, 2, 11, 6, 0, 3, 0) {
		acquire(2, anc, 4, nb);
		Toffoli( anc[1], q[0], anc[0] );
		Toffoli( anc[0], q[0], anc[1] );
		Toffoli( anc[1], anc[0], q[0] );
		CNOT( anc[0], anc[1] );
		CNOT( q[0], anc[0] );
	}
	Store {
		CNOT( anc[1], res[0] );
	}
	Uncompute(res, 0, anc, 2, 11, 6){
		CNOT( q[0], anc[0] );
		CNOT( anc[0], anc[1] );
		Toffoli( anc[1], anc[0], q[0] );
		Toffoli( anc[0], q[0], anc[1] );
		Toffoli( anc[1], q[0], anc[0] );
	} Free(anc, 2) {}
}
// Function 20 with degree 0
// nq: 1, na: 2, ng: 5
void func20R(qbit **q, int n) {
printf("func20R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[4]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	nb[1] = q[0];
	nb[2] = q[0];
	nb[3] = q[0];
	res[0] = q[0];
	// Leaf function
	_computeModule(0, 2, 11, 6, 0, 3, 0);
	acquire(2, anc, 4, nb);
	Recompute (res, 0, anc, 2, 11, 6){
		CNOT( q[0], anc[0] );
		CNOT( anc[0], anc[1] );
		Toffoli( anc[1], anc[0], q[0] );
		Toffoli( anc[0], q[0], anc[1] );
		Toffoli( anc[1], q[0], anc[0] );
	}
	Restore {
		CNOT( anc[1], res[0] );
	}
	Unrecompute {
		Toffoli( anc[1], q[0], anc[0] );
		Toffoli( anc[0], q[0], anc[1] );
		Toffoli( anc[1], anc[0], q[0] );
		CNOT( anc[0], anc[1] );
		CNOT( q[0], anc[0] );
	} Refree(anc, 2) {}
}
// Function 19 with degree 0
// nq: 3, na: 7, ng: 2
void func19(qbit **q, int n) {
printf("func19\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[3];
	nb[0] = q[2];
	nb[1] = q[1];
	res[0] = q[0];
	res[1] = q[1];
	res[2] = q[2];
	// Leaf function
	Compute (0, 7, 7, 5, 0, 3, 0) {
		acquire(7, anc, 2, nb);
		CNOT( q[2], anc[3] );
		Toffoli( anc[1], anc[4], q[1] );
	}
	Store {
		CNOT( anc[5], res[0] );
		CNOT( q[2], res[1] );
		CNOT( anc[1], res[2] );
	}
	Uncompute(res, 0, anc, 7, 7, 5){
		Toffoli( anc[1], anc[4], q[1] );
		CNOT( q[2], anc[3] );
	} Free(anc, 7) {}
}
// Function 19 with degree 0
// nq: 3, na: 7, ng: 2
void func19R(qbit **q, int n) {
printf("func19R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[3];
	nb[0] = q[2];
	nb[1] = q[1];
	res[0] = q[0];
	res[1] = q[1];
	res[2] = q[2];
	// Leaf function
	_computeModule(0, 7, 7, 5, 0, 3, 0);
	acquire(7, anc, 2, nb);
	Recompute (res, 0, anc, 7, 7, 5){
		Toffoli( anc[1], anc[4], q[1] );
		CNOT( q[2], anc[3] );
	}
	Restore {
		CNOT( anc[5], res[0] );
		CNOT( q[2], res[1] );
		CNOT( anc[1], res[2] );
	}
	Unrecompute {
		CNOT( q[2], anc[3] );
		Toffoli( anc[1], anc[4], q[1] );
	} Refree(anc, 7) {}
}
// Function 18 with degree 0
// nq: 3, na: 7, ng: 3
void func18(qbit **q, int n) {
printf("func18\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[3];
	nb[0] = q[2];
	nb[1] = q[2];
	res[0] = q[1];
	res[1] = q[2];
	res[2] = q[0];
	// Leaf function
	Compute (0, 7, 9, 6, 0, 3, 0) {
		acquire(7, anc, 2, nb);
		CNOT( q[2], anc[2] );
		CNOT( anc[4], anc[1] );
		CNOT( anc[5], q[2] );
	}
	Store {
		CNOT( q[0], res[0] );
		CNOT( anc[5], res[1] );
		CNOT( q[2], res[2] );
	}
	Uncompute(res, 0, anc, 7, 9, 6){
		CNOT( anc[5], q[2] );
		CNOT( anc[4], anc[1] );
		CNOT( q[2], anc[2] );
	} Free(anc, 7) {}
}
// Function 18 with degree 0
// nq: 3, na: 7, ng: 3
void func18R(qbit **q, int n) {
printf("func18R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[3];
	nb[0] = q[2];
	nb[1] = q[2];
	res[0] = q[1];
	res[1] = q[2];
	res[2] = q[0];
	// Leaf function
	_computeModule(0, 7, 9, 6, 0, 3, 0);
	acquire(7, anc, 2, nb);
	Recompute (res, 0, anc, 7, 9, 6){
		CNOT( anc[5], q[2] );
		CNOT( anc[4], anc[1] );
		CNOT( q[2], anc[2] );
	}
	Restore {
		CNOT( q[0], res[0] );
		CNOT( anc[5], res[1] );
		CNOT( q[2], res[2] );
	}
	Unrecompute {
		CNOT( q[2], anc[2] );
		CNOT( anc[4], anc[1] );
		CNOT( anc[5], q[2] );
	} Refree(anc, 7) {}
}
// Function 17 with degree 0
// nq: 3, na: 2, ng: 8
void func17(qbit **q, int n) {
printf("func17\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[13]; // interacting bits
	qbit *res[3];
	nb[0] = q[0];
	nb[1] = q[1];
	nb[2] = q[2];
	nb[3] = q[1];
	nb[4] = q[2];
	nb[5] = q[0];
	nb[6] = q[1];
	nb[7] = q[1];
	nb[8] = q[2];
	nb[9] = q[1];
	nb[10] = q[1];
	nb[11] = q[2];
	nb[12] = q[2];
	res[0] = q[1];
	res[1] = q[0];
	res[2] = q[2];
	// Leaf function
	Compute (0, 2, 19, 11, 0, 3, 0) {
		acquire(2, anc, 13, nb);
		Toffoli( q[0], q[1], anc[1] );
		Toffoli( anc[1], q[2], q[1] );
		CNOT( anc[0], q[2] );
		Toffoli( anc[0], q[0], q[1] );
		Toffoli( q[1], q[2], anc[1] );
		CNOT( q[1], anc[1] );
		Toffoli( q[1], anc[0], q[2] );
		CNOT( anc[0], q[2] );
	}
	Store {
		CNOT( q[2], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( anc[1], res[2] );
	}
	Uncompute(res, 0, anc, 2, 19, 11){
		CNOT( anc[0], q[2] );
		Toffoli( q[1], anc[0], q[2] );
		CNOT( q[1], anc[1] );
		Toffoli( q[1], q[2], anc[1] );
		Toffoli( anc[0], q[0], q[1] );
		CNOT( anc[0], q[2] );
		Toffoli( anc[1], q[2], q[1] );
		Toffoli( q[0], q[1], anc[1] );
	} Free(anc, 2) {}
}
// Function 17 with degree 0
// nq: 3, na: 2, ng: 8
void func17R(qbit **q, int n) {
printf("func17R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[13]; // interacting bits
	qbit *res[3];
	nb[0] = q[0];
	nb[1] = q[1];
	nb[2] = q[2];
	nb[3] = q[1];
	nb[4] = q[2];
	nb[5] = q[0];
	nb[6] = q[1];
	nb[7] = q[1];
	nb[8] = q[2];
	nb[9] = q[1];
	nb[10] = q[1];
	nb[11] = q[2];
	nb[12] = q[2];
	res[0] = q[1];
	res[1] = q[0];
	res[2] = q[2];
	// Leaf function
	_computeModule(0, 2, 19, 11, 0, 3, 0);
	acquire(2, anc, 13, nb);
	Recompute (res, 0, anc, 2, 19, 11){
		CNOT( anc[0], q[2] );
		Toffoli( q[1], anc[0], q[2] );
		CNOT( q[1], anc[1] );
		Toffoli( q[1], q[2], anc[1] );
		Toffoli( anc[0], q[0], q[1] );
		CNOT( anc[0], q[2] );
		Toffoli( anc[1], q[2], q[1] );
		Toffoli( q[0], q[1], anc[1] );
	}
	Restore {
		CNOT( q[2], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( anc[1], res[2] );
	}
	Unrecompute {
		Toffoli( q[0], q[1], anc[1] );
		Toffoli( anc[1], q[2], q[1] );
		CNOT( anc[0], q[2] );
		Toffoli( anc[0], q[0], q[1] );
		Toffoli( q[1], q[2], anc[1] );
		CNOT( q[1], anc[1] );
		Toffoli( q[1], anc[0], q[2] );
		CNOT( anc[0], q[2] );
	} Refree(anc, 2) {}
}
// Function 16 with degree 0
// nq: 10, na: 6, ng: 5
void func16(qbit **q, int n) {
printf("func16\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[6];
	nb[0] = q[2];
	nb[1] = q[7];
	nb[2] = q[3];
	nb[3] = q[2];
	nb[4] = q[1];
	nb[5] = q[6];
	res[0] = q[6];
	res[1] = q[1];
	res[2] = q[5];
	res[3] = q[3];
	res[4] = q[2];
	res[5] = q[7];
	// Leaf function
	Compute (0, 6, 16, 11, 0, 1, 0) {
		acquire(6, anc, 6, nb);
		CNOT( anc[3], q[2] );
		CNOT( q[7], anc[3] );
		CNOT( anc[5], q[3] );
		CNOT( q[2], anc[0] );
		Toffoli( anc[4], q[1], q[6] );
	}
	Store {
		CNOT( anc[4], res[0] );
		CNOT( q[7], res[1] );
		CNOT( anc[3], res[2] );
		CNOT( anc[0], res[3] );
		CNOT( q[4], res[4] );
		CNOT( q[8], res[5] );
	}
	Uncompute(res, 0, anc, 6, 16, 11){
		Toffoli( anc[4], q[1], q[6] );
		CNOT( q[2], anc[0] );
		CNOT( anc[5], q[3] );
		CNOT( q[7], anc[3] );
		CNOT( anc[3], q[2] );
	} Free(anc, 6) {}
}
// Function 16 with degree 0
// nq: 10, na: 6, ng: 5
void func16R(qbit **q, int n) {
printf("func16R\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[6];
	nb[0] = q[2];
	nb[1] = q[7];
	nb[2] = q[3];
	nb[3] = q[2];
	nb[4] = q[1];
	nb[5] = q[6];
	res[0] = q[6];
	res[1] = q[1];
	res[2] = q[5];
	res[3] = q[3];
	res[4] = q[2];
	res[5] = q[7];
	// Leaf function
	_computeModule(0, 6, 16, 11, 0, 1, 0);
	acquire(6, anc, 6, nb);
	Recompute (res, 0, anc, 6, 16, 11){
		Toffoli( anc[4], q[1], q[6] );
		CNOT( q[2], anc[0] );
		CNOT( anc[5], q[3] );
		CNOT( q[7], anc[3] );
		CNOT( anc[3], q[2] );
	}
	Restore {
		CNOT( anc[4], res[0] );
		CNOT( q[7], res[1] );
		CNOT( anc[3], res[2] );
		CNOT( anc[0], res[3] );
		CNOT( q[4], res[4] );
		CNOT( q[8], res[5] );
	}
	Unrecompute {
		CNOT( anc[3], q[2] );
		CNOT( q[7], anc[3] );
		CNOT( anc[5], q[3] );
		CNOT( q[2], anc[0] );
		Toffoli( anc[4], q[1], q[6] );
	} Refree(anc, 6) {}
}
// Function 15 with degree 2
// nq: 11, na: 2, ng: 5
void func15(qbit **q, int n) {
printf("func15\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[14]; // interacting bits
	qbit *res[4];
	qbit *nq0[6];
	qbit *nq1[6];
	nb[0] = q[0];
	nb[1] = q[10];
	nb[2] = q[9];
	nb[3] = q[9];
	nb[4] = q[8];
	nb[5] = q[3];
	nb[6] = q[7];
	nb[7] = q[5];
	nb[8] = q[0];
	nb[9] = q[6];
	nb[10] = q[4];
	nb[11] = q[7];
	nb[12] = q[1];
	nb[13] = q[0];
	res[0] = q[4];
	res[1] = q[3];
	res[2] = q[9];
	res[3] = q[7];
	// Non-leaf function
	Compute (0, 2, 14, 9, 2, 1, 0){
		acquire(2, anc, 14, nb);
	nq0[0] = q[2];
	nq0[1] = anc[0];
	nq0[2] = q[9];
	nq0[3] = q[7];
	nq0[4] = q[3];
	nq0[5] = q[4];
	nq1[0] = anc[1];
	nq1[1] = q[1];
	nq1[2] = q[10];
	nq1[3] = q[6];
	nq1[4] = q[8];
	nq1[5] = q[0];
		func28(nq1, 6);
		Toffoli( q[0], q[6], q[4] );
		CNOT( q[7], q[5] );
		Toffoli( q[0], q[10], q[9] );
		Toffoli( q[9], q[8], q[3] );
		Toffoli( q[7], q[1], q[0] );
		func27(nq0, 6);
	}
	Store {
		CNOT( q[0], res[0] );
		CNOT( q[6], res[1] );
		CNOT( anc[1], res[2] );
		CNOT( q[10], res[3] );
	}
	Uncompute(res, 0, anc, 2, 14, 9){
		func27R(nq0, 6);
		Toffoli( q[7], q[1], q[0] );
		Toffoli( q[9], q[8], q[3] );
		Toffoli( q[0], q[10], q[9] );
		CNOT( q[7], q[5] );
		Toffoli( q[0], q[6], q[4] );
		func28R(nq1, 6);
	} Free(anc, 2) {}
}
// Function 15 with degree 2
// nq: 11, na: 2, ng: 5
void func15R(qbit **q, int n) {
printf("func15R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[14]; // interacting bits
	qbit *res[4];
	qbit *nq0[6];
	qbit *nq1[6];
	nb[0] = q[0];
	nb[1] = q[10];
	nb[2] = q[9];
	nb[3] = q[9];
	nb[4] = q[8];
	nb[5] = q[3];
	nb[6] = q[7];
	nb[7] = q[5];
	nb[8] = q[0];
	nb[9] = q[6];
	nb[10] = q[4];
	nb[11] = q[7];
	nb[12] = q[1];
	nb[13] = q[0];
	res[0] = q[4];
	res[1] = q[3];
	res[2] = q[9];
	res[3] = q[7];
	// Non-leaf function
	_computeModule(0, 2, 14, 9, 2, 1, 0);
	acquire(2, anc, 14, nb);
	nq0[0] = q[2];
	nq0[1] = anc[0];
	nq0[2] = q[9];
	nq0[3] = q[7];
	nq0[4] = q[3];
	nq0[5] = q[4];
	nq1[0] = anc[1];
	nq1[1] = q[1];
	nq1[2] = q[10];
	nq1[3] = q[6];
	nq1[4] = q[8];
	nq1[5] = q[0];
	Recompute(res, 0, anc, 2, 14, 9){
		func28(nq1, 6);
		Toffoli( q[0], q[6], q[4] );
		CNOT( q[7], q[5] );
		Toffoli( q[0], q[10], q[9] );
		Toffoli( q[9], q[8], q[3] );
		Toffoli( q[7], q[1], q[0] );
		func27(nq0, 6);
	}
	Restore {
		CNOT( q[0], res[0] );
		CNOT( q[6], res[1] );
		CNOT( anc[1], res[2] );
		CNOT( q[10], res[3] );
	}
	Unrecompute {
		func27R(nq0, 6);
		Toffoli( q[7], q[1], q[0] );
		Toffoli( q[9], q[8], q[3] );
		Toffoli( q[0], q[10], q[9] );
		CNOT( q[7], q[5] );
		Toffoli( q[0], q[6], q[4] );
		func28R(nq1, 6);
	} Refree(anc, 2) {}
}
// Function 14 with degree 2
// nq: 5, na: 4, ng: 6
void func14(qbit **q, int n) {
printf("func14\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[10]; // interacting bits
	qbit *res[2];
	qbit *nq0[4];
	qbit *nq1[4];
	nb[0] = q[0];
	nb[1] = q[2];
	nb[2] = q[2];
	nb[3] = q[1];
	nb[4] = q[0];
	nb[5] = q[4];
	nb[6] = q[1];
	nb[7] = q[3];
	nb[8] = q[2];
	nb[9] = q[3];
	res[0] = q[0];
	res[1] = q[2];
	// Non-leaf function
	Compute (0, 4, 14, 8, 2, 1, 0){
		acquire(4, anc, 10, nb);
	nq0[0] = anc[2];
	nq0[1] = q[0];
	nq0[2] = q[3];
	nq0[3] = anc[0];
	nq1[0] = q[2];
	nq1[1] = q[1];
	nq1[2] = anc[1];
	nq1[3] = q[4];
		Toffoli( anc[2], q[0], q[4] );
		CNOT( q[2], q[1] );
		Toffoli( q[3], anc[3], anc[2] );
		CNOT( q[0], q[2] );
		func26(nq1, 4);
		CNOT( anc[2], q[2] );
		func25(nq0, 4);
		CNOT( q[1], q[3] );
	}
	Store {
		CNOT( anc[0], res[0] );
		CNOT( q[4], res[1] );
	}
	Uncompute(res, 0, anc, 4, 14, 8){
		CNOT( q[1], q[3] );
		func25R(nq0, 4);
		CNOT( anc[2], q[2] );
		func26R(nq1, 4);
		CNOT( q[0], q[2] );
		Toffoli( q[3], anc[3], anc[2] );
		CNOT( q[2], q[1] );
		Toffoli( anc[2], q[0], q[4] );
	} Free(anc, 4) {}
}
// Function 14 with degree 2
// nq: 5, na: 4, ng: 6
void func14R(qbit **q, int n) {
printf("func14R\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[10]; // interacting bits
	qbit *res[2];
	qbit *nq0[4];
	qbit *nq1[4];
	nb[0] = q[0];
	nb[1] = q[2];
	nb[2] = q[2];
	nb[3] = q[1];
	nb[4] = q[0];
	nb[5] = q[4];
	nb[6] = q[1];
	nb[7] = q[3];
	nb[8] = q[2];
	nb[9] = q[3];
	res[0] = q[0];
	res[1] = q[2];
	// Non-leaf function
	_computeModule(0, 4, 14, 8, 2, 1, 0);
	acquire(4, anc, 10, nb);
	nq0[0] = anc[2];
	nq0[1] = q[0];
	nq0[2] = q[3];
	nq0[3] = anc[0];
	nq1[0] = q[2];
	nq1[1] = q[1];
	nq1[2] = anc[1];
	nq1[3] = q[4];
	Recompute(res, 0, anc, 4, 14, 8){
		Toffoli( anc[2], q[0], q[4] );
		CNOT( q[2], q[1] );
		Toffoli( q[3], anc[3], anc[2] );
		CNOT( q[0], q[2] );
		func26(nq1, 4);
		CNOT( anc[2], q[2] );
		func25(nq0, 4);
		CNOT( q[1], q[3] );
	}
	Restore {
		CNOT( anc[0], res[0] );
		CNOT( q[4], res[1] );
	}
	Unrecompute {
		CNOT( q[1], q[3] );
		func25R(nq0, 4);
		CNOT( anc[2], q[2] );
		func26R(nq1, 4);
		CNOT( q[0], q[2] );
		Toffoli( q[3], anc[3], anc[2] );
		CNOT( q[2], q[1] );
		Toffoli( anc[2], q[0], q[4] );
	} Refree(anc, 4) {}
}
// Function 13 with degree 2
// nq: 1, na: 4, ng: 6
void func13(qbit **q, int n) {
printf("func13\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[1];
	qbit *nq0[2];
	qbit *nq1[2];
	nb[0] = q[0];
	nb[1] = q[0];
	res[0] = q[0];
	// Non-leaf function
	Compute (0, 4, 13, 7, 2, 3, 0){
		acquire(4, anc, 2, nb);
	nq0[0] = anc[1];
	nq0[1] = anc[0];
	nq1[0] = anc[3];
	nq1[1] = anc[2];
		CNOT( anc[0], anc[1] );
		func23(nq0, 2);
		Toffoli( q[0], anc[2], anc[1] );
		CNOT( anc[3], anc[0] );
		CNOT( anc[3], anc[1] );
		Toffoli( anc[2], anc[3], anc[1] );
		Toffoli( q[0], anc[0], anc[1] );
		func24(nq1, 2);
	}
	Store {
		CNOT( anc[0], res[0] );
	}
	Uncompute(res, 0, anc, 4, 13, 7){
		func24R(nq1, 2);
		Toffoli( q[0], anc[0], anc[1] );
		Toffoli( anc[2], anc[3], anc[1] );
		CNOT( anc[3], anc[1] );
		CNOT( anc[3], anc[0] );
		Toffoli( q[0], anc[2], anc[1] );
		func23R(nq0, 2);
		CNOT( anc[0], anc[1] );
	} Free(anc, 4) {}
}
// Function 13 with degree 2
// nq: 1, na: 4, ng: 6
void func13R(qbit **q, int n) {
printf("func13R\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[1];
	qbit *nq0[2];
	qbit *nq1[2];
	nb[0] = q[0];
	nb[1] = q[0];
	res[0] = q[0];
	// Non-leaf function
	_computeModule(0, 4, 13, 7, 2, 3, 0);
	acquire(4, anc, 2, nb);
	nq0[0] = anc[1];
	nq0[1] = anc[0];
	nq1[0] = anc[3];
	nq1[1] = anc[2];
	Recompute(res, 0, anc, 4, 13, 7){
		CNOT( anc[0], anc[1] );
		func23(nq0, 2);
		Toffoli( q[0], anc[2], anc[1] );
		CNOT( anc[3], anc[0] );
		CNOT( anc[3], anc[1] );
		Toffoli( anc[2], anc[3], anc[1] );
		Toffoli( q[0], anc[0], anc[1] );
		func24(nq1, 2);
	}
	Restore {
		CNOT( anc[0], res[0] );
	}
	Unrecompute {
		func24R(nq1, 2);
		Toffoli( q[0], anc[0], anc[1] );
		Toffoli( anc[2], anc[3], anc[1] );
		CNOT( anc[3], anc[1] );
		CNOT( anc[3], anc[0] );
		Toffoli( q[0], anc[2], anc[1] );
		func23R(nq0, 2);
		CNOT( anc[0], anc[1] );
	} Refree(anc, 4) {}
}
// Function 12 with degree 3
// nq: 1, na: 4, ng: 7
void func12(qbit **q, int n) {
printf("func12\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[4]; // interacting bits
	qbit *res[1];
	qbit *nq0[1];
	qbit *nq1[1];
	qbit *nq2[1];
	nb[0] = q[0];
	nb[1] = q[0];
	nb[2] = q[0];
	nb[3] = q[0];
	res[0] = q[0];
	// Non-leaf function
	Compute (0, 4, 15, 8, 3, 3, 0){
		acquire(4, anc, 4, nb);
	nq0[0] = anc[0];
	nq1[0] = anc[1];
	nq2[0] = anc[2];
		Toffoli( q[0], anc[0], anc[1] );
		func21(nq1, 1);
		CNOT( anc[3], anc[1] );
		CNOT( anc[3], q[0] );
		Toffoli( anc[3], q[0], anc[1] );
		Toffoli( anc[2], anc[1], anc[3] );
		Toffoli( anc[3], anc[1], anc[0] );
		func22(nq2, 1);
		Toffoli( q[0], anc[2], anc[1] );
		func20(nq0, 1);
	}
	Store {
		CNOT( anc[3], res[0] );
	}
	Uncompute(res, 0, anc, 4, 15, 8){
		func20R(nq0, 1);
		Toffoli( q[0], anc[2], anc[1] );
		func22R(nq2, 1);
		Toffoli( anc[3], anc[1], anc[0] );
		Toffoli( anc[2], anc[1], anc[3] );
		Toffoli( anc[3], q[0], anc[1] );
		CNOT( anc[3], q[0] );
		CNOT( anc[3], anc[1] );
		func21R(nq1, 1);
		Toffoli( q[0], anc[0], anc[1] );
	} Free(anc, 4) {}
}
// Function 12 with degree 3
// nq: 1, na: 4, ng: 7
void func12R(qbit **q, int n) {
printf("func12R\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[4]; // interacting bits
	qbit *res[1];
	qbit *nq0[1];
	qbit *nq1[1];
	qbit *nq2[1];
	nb[0] = q[0];
	nb[1] = q[0];
	nb[2] = q[0];
	nb[3] = q[0];
	res[0] = q[0];
	// Non-leaf function
	_computeModule(0, 4, 15, 8, 3, 3, 0);
	acquire(4, anc, 4, nb);
	nq0[0] = anc[0];
	nq1[0] = anc[1];
	nq2[0] = anc[2];
	Recompute(res, 0, anc, 4, 15, 8){
		Toffoli( q[0], anc[0], anc[1] );
		func21(nq1, 1);
		CNOT( anc[3], anc[1] );
		CNOT( anc[3], q[0] );
		Toffoli( anc[3], q[0], anc[1] );
		Toffoli( anc[2], anc[1], anc[3] );
		Toffoli( anc[3], anc[1], anc[0] );
		func22(nq2, 1);
		Toffoli( q[0], anc[2], anc[1] );
		func20(nq0, 1);
	}
	Restore {
		CNOT( anc[3], res[0] );
	}
	Unrecompute {
		func20R(nq0, 1);
		Toffoli( q[0], anc[2], anc[1] );
		func22R(nq2, 1);
		Toffoli( anc[3], anc[1], anc[0] );
		Toffoli( anc[2], anc[1], anc[3] );
		Toffoli( anc[3], q[0], anc[1] );
		CNOT( anc[3], q[0] );
		CNOT( anc[3], anc[1] );
		func21R(nq1, 1);
		Toffoli( q[0], anc[0], anc[1] );
	} Refree(anc, 4) {}
}
// Function 11 with degree 0
// nq: 1, na: 8, ng: 3
void func11(qbit **q, int n) {
printf("func11\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[1]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	res[0] = q[0];
	// Leaf function
	Compute (0, 8, 7, 4, 0, 3, 0) {
		acquire(8, anc, 1, nb);
		CNOT( anc[0], anc[4] );
		CNOT( q[0], anc[6] );
		Toffoli( anc[2], anc[4], anc[6] );
	}
	Store {
		CNOT( anc[5], res[0] );
	}
	Uncompute(res, 0, anc, 8, 7, 4){
		Toffoli( anc[2], anc[4], anc[6] );
		CNOT( q[0], anc[6] );
		CNOT( anc[0], anc[4] );
	} Free(anc, 8) {}
}
// Function 11 with degree 0
// nq: 1, na: 8, ng: 3
void func11R(qbit **q, int n) {
printf("func11R\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[1]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	res[0] = q[0];
	// Leaf function
	_computeModule(0, 8, 7, 4, 0, 3, 0);
	acquire(8, anc, 1, nb);
	Recompute (res, 0, anc, 8, 7, 4){
		Toffoli( anc[2], anc[4], anc[6] );
		CNOT( q[0], anc[6] );
		CNOT( anc[0], anc[4] );
	}
	Restore {
		CNOT( anc[5], res[0] );
	}
	Unrecompute {
		CNOT( anc[0], anc[4] );
		CNOT( q[0], anc[6] );
		Toffoli( anc[2], anc[4], anc[6] );
	} Refree(anc, 8) {}
}
// Function 10 with degree 3
// nq: 4, na: 6, ng: 6
void func10(qbit **q, int n) {
printf("func10\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[7]; // interacting bits
	qbit *res[4];
	qbit *nq0[3];
	qbit *nq1[3];
	qbit *nq2[3];
	nb[0] = q[2];
	nb[1] = q[1];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[3];
	nb[5] = q[2];
	nb[6] = q[3];
	res[0] = q[0];
	res[1] = q[2];
	res[2] = q[1];
	res[3] = q[3];
	// Non-leaf function
	Compute (0, 6, 16, 10, 3, 2, 0){
		acquire(6, anc, 7, nb);
	nq0[0] = anc[3];
	nq0[1] = q[3];
	nq0[2] = anc[2];
	nq1[0] = anc[1];
	nq1[1] = anc[4];
	nq1[2] = q[2];
	nq2[0] = anc[5];
	nq2[1] = anc[0];
	nq2[2] = q[1];
		Toffoli( anc[4], q[1], anc[0] );
		func17(nq0, 3);
		CNOT( q[0], anc[0] );
		func19(nq2, 3);
		CNOT( q[1], anc[1] );
		CNOT( anc[5], q[3] );
		func18(nq1, 3);
		CNOT( q[2], anc[5] );
		Toffoli( anc[0], q[2], q[3] );
	}
	Store {
		CNOT( anc[1], res[0] );
		CNOT( anc[5], res[1] );
		CNOT( anc[1], res[2] );
		CNOT( anc[0], res[3] );
	}
	Uncompute(res, 0, anc, 6, 16, 10){
		Toffoli( anc[0], q[2], q[3] );
		CNOT( q[2], anc[5] );
		func18R(nq1, 3);
		CNOT( anc[5], q[3] );
		CNOT( q[1], anc[1] );
		func19R(nq2, 3);
		CNOT( q[0], anc[0] );
		func17R(nq0, 3);
		Toffoli( anc[4], q[1], anc[0] );
	} Free(anc, 6) {}
}
// Function 10 with degree 3
// nq: 4, na: 6, ng: 6
void func10R(qbit **q, int n) {
printf("func10R\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[7]; // interacting bits
	qbit *res[4];
	qbit *nq0[3];
	qbit *nq1[3];
	qbit *nq2[3];
	nb[0] = q[2];
	nb[1] = q[1];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[3];
	nb[5] = q[2];
	nb[6] = q[3];
	res[0] = q[0];
	res[1] = q[2];
	res[2] = q[1];
	res[3] = q[3];
	// Non-leaf function
	_computeModule(0, 6, 16, 10, 3, 2, 0);
	acquire(6, anc, 7, nb);
	nq0[0] = anc[3];
	nq0[1] = q[3];
	nq0[2] = anc[2];
	nq1[0] = anc[1];
	nq1[1] = anc[4];
	nq1[2] = q[2];
	nq2[0] = anc[5];
	nq2[1] = anc[0];
	nq2[2] = q[1];
	Recompute(res, 0, anc, 6, 16, 10){
		Toffoli( anc[4], q[1], anc[0] );
		func17(nq0, 3);
		CNOT( q[0], anc[0] );
		func19(nq2, 3);
		CNOT( q[1], anc[1] );
		CNOT( anc[5], q[3] );
		func18(nq1, 3);
		CNOT( q[2], anc[5] );
		Toffoli( anc[0], q[2], q[3] );
	}
	Restore {
		CNOT( anc[1], res[0] );
		CNOT( anc[5], res[1] );
		CNOT( anc[1], res[2] );
		CNOT( anc[0], res[3] );
	}
	Unrecompute {
		Toffoli( anc[0], q[2], q[3] );
		CNOT( q[2], anc[5] );
		func18R(nq1, 3);
		CNOT( anc[5], q[3] );
		CNOT( q[1], anc[1] );
		func19R(nq2, 3);
		CNOT( q[0], anc[0] );
		func17R(nq0, 3);
		Toffoli( anc[4], q[1], anc[0] );
	} Refree(anc, 6) {}
}
// Function 9 with degree 1
// nq: 4, na: 6, ng: 7
void func9(qbit **q, int n) {
printf("func9\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[4];
	qbit *nq0[10];
	nb[0] = q[0];
	nb[1] = q[3];
	nb[2] = q[2];
	nb[3] = q[3];
	nb[4] = q[3];
	nb[5] = q[2];
	nb[6] = q[2];
	nb[7] = q[3];
	nb[8] = q[2];
	res[0] = q[0];
	res[1] = q[1];
	res[2] = q[2];
	res[3] = q[3];
	// Non-leaf function
	Compute (0, 6, 18, 11, 1, 2, 0){
		acquire(6, anc, 9, nb);
	nq0[0] = anc[3];
	nq0[1] = anc[4];
	nq0[2] = q[3];
	nq0[3] = anc[0];
	nq0[4] = anc[2];
	nq0[5] = q[0];
	nq0[6] = anc[1];
	nq0[7] = q[2];
	nq0[8] = anc[5];
	nq0[9] = q[1];
		CNOT( anc[5], anc[2] );
		CNOT( q[3], q[2] );
		func16(nq0, 10);
		CNOT( q[3], anc[0] );
		CNOT( anc[2], q[0] );
		CNOT( q[3], q[2] );
		Toffoli( q[2], anc[0], anc[4] );
		CNOT( q[3], q[2] );
	}
	Store {
		CNOT( q[2], res[0] );
		CNOT( q[3], res[1] );
		CNOT( q[0], res[2] );
		CNOT( anc[0], res[3] );
	}
	Uncompute(res, 0, anc, 6, 18, 11){
		CNOT( q[3], q[2] );
		Toffoli( q[2], anc[0], anc[4] );
		CNOT( q[3], q[2] );
		CNOT( anc[2], q[0] );
		CNOT( q[3], anc[0] );
		func16R(nq0, 10);
		CNOT( q[3], q[2] );
		CNOT( anc[5], anc[2] );
	} Free(anc, 6) {}
}
// Function 9 with degree 1
// nq: 4, na: 6, ng: 7
void func9R(qbit **q, int n) {
printf("func9R\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[4];
	qbit *nq0[10];
	nb[0] = q[0];
	nb[1] = q[3];
	nb[2] = q[2];
	nb[3] = q[3];
	nb[4] = q[3];
	nb[5] = q[2];
	nb[6] = q[2];
	nb[7] = q[3];
	nb[8] = q[2];
	res[0] = q[0];
	res[1] = q[1];
	res[2] = q[2];
	res[3] = q[3];
	// Non-leaf function
	_computeModule(0, 6, 18, 11, 1, 2, 0);
	acquire(6, anc, 9, nb);
	nq0[0] = anc[3];
	nq0[1] = anc[4];
	nq0[2] = q[3];
	nq0[3] = anc[0];
	nq0[4] = anc[2];
	nq0[5] = q[0];
	nq0[6] = anc[1];
	nq0[7] = q[2];
	nq0[8] = anc[5];
	nq0[9] = q[1];
	Recompute(res, 0, anc, 6, 18, 11){
		CNOT( anc[5], anc[2] );
		CNOT( q[3], q[2] );
		func16(nq0, 10);
		CNOT( q[3], anc[0] );
		CNOT( anc[2], q[0] );
		CNOT( q[3], q[2] );
		Toffoli( q[2], anc[0], anc[4] );
		CNOT( q[3], q[2] );
	}
	Restore {
		CNOT( q[2], res[0] );
		CNOT( q[3], res[1] );
		CNOT( q[0], res[2] );
		CNOT( anc[0], res[3] );
	}
	Unrecompute {
		CNOT( q[3], q[2] );
		Toffoli( q[2], anc[0], anc[4] );
		CNOT( q[3], q[2] );
		CNOT( anc[2], q[0] );
		CNOT( q[3], anc[0] );
		func16R(nq0, 10);
		CNOT( q[3], q[2] );
		CNOT( anc[5], anc[2] );
	} Refree(anc, 6) {}
}
// Function 8 with degree 1
// nq: 4, na: 7, ng: 7
void func8(qbit **q, int n) {
printf("func8\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[2];
	qbit *nq0[11];
	nb[0] = q[1];
	nb[1] = q[1];
	nb[2] = q[3];
	nb[3] = q[1];
	nb[4] = q[0];
	nb[5] = q[1];
	res[0] = q[2];
	res[1] = q[0];
	// Non-leaf function
	Compute (0, 7, 16, 9, 1, 2, 0){
		acquire(7, anc, 6, nb);
	nq0[0] = anc[6];
	nq0[1] = q[3];
	nq0[2] = q[2];
	nq0[3] = q[1];
	nq0[4] = anc[1];
	nq0[5] = anc[0];
	nq0[6] = anc[4];
	nq0[7] = anc[3];
	nq0[8] = anc[2];
	nq0[9] = anc[5];
	nq0[10] = q[0];
		CNOT( anc[0], anc[6] );
		Toffoli( anc[2], anc[3], q[1] );
		Toffoli( q[1], anc[6], anc[1] );
		func15(nq0, 11);
		Toffoli( anc[3], anc[0], q[1] );
		Toffoli( anc[2], anc[5], q[3] );
		Toffoli( q[1], anc[2], q[0] );
		CNOT( anc[4], anc[5] );
	}
	Store {
		CNOT( anc[5], res[0] );
		CNOT( anc[6], res[1] );
	}
	Uncompute(res, 0, anc, 7, 16, 9){
		CNOT( anc[4], anc[5] );
		Toffoli( q[1], anc[2], q[0] );
		Toffoli( anc[2], anc[5], q[3] );
		Toffoli( anc[3], anc[0], q[1] );
		func15R(nq0, 11);
		Toffoli( q[1], anc[6], anc[1] );
		Toffoli( anc[2], anc[3], q[1] );
		CNOT( anc[0], anc[6] );
	} Free(anc, 7) {}
}
// Function 8 with degree 1
// nq: 4, na: 7, ng: 7
void func8R(qbit **q, int n) {
printf("func8R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[2];
	qbit *nq0[11];
	nb[0] = q[1];
	nb[1] = q[1];
	nb[2] = q[3];
	nb[3] = q[1];
	nb[4] = q[0];
	nb[5] = q[1];
	res[0] = q[2];
	res[1] = q[0];
	// Non-leaf function
	_computeModule(0, 7, 16, 9, 1, 2, 0);
	acquire(7, anc, 6, nb);
	nq0[0] = anc[6];
	nq0[1] = q[3];
	nq0[2] = q[2];
	nq0[3] = q[1];
	nq0[4] = anc[1];
	nq0[5] = anc[0];
	nq0[6] = anc[4];
	nq0[7] = anc[3];
	nq0[8] = anc[2];
	nq0[9] = anc[5];
	nq0[10] = q[0];
	Recompute(res, 0, anc, 7, 16, 9){
		CNOT( anc[0], anc[6] );
		Toffoli( anc[2], anc[3], q[1] );
		Toffoli( q[1], anc[6], anc[1] );
		func15(nq0, 11);
		Toffoli( anc[3], anc[0], q[1] );
		Toffoli( anc[2], anc[5], q[3] );
		Toffoli( q[1], anc[2], q[0] );
		CNOT( anc[4], anc[5] );
	}
	Restore {
		CNOT( anc[5], res[0] );
		CNOT( anc[6], res[1] );
	}
	Unrecompute {
		CNOT( anc[4], anc[5] );
		Toffoli( q[1], anc[2], q[0] );
		Toffoli( anc[2], anc[5], q[3] );
		Toffoli( anc[3], anc[0], q[1] );
		func15R(nq0, 11);
		Toffoli( q[1], anc[6], anc[1] );
		Toffoli( anc[2], anc[3], q[1] );
		CNOT( anc[0], anc[6] );
	} Refree(anc, 7) {}
}
// Function 7 with degree 0
// nq: 4, na: 5, ng: 1
void func7(qbit **q, int n) {
printf("func7\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[1]; // interacting bits
	qbit *res[2];
	nb[0] = q[2];
	res[0] = q[3];
	res[1] = q[0];
	// Leaf function
	Compute (0, 5, 4, 3, 0, 2, 0) {
		acquire(5, anc, 1, nb);
		Toffoli( anc[2], anc[3], q[2] );
	}
	Store {
		CNOT( anc[1], res[0] );
		CNOT( anc[1], res[1] );
	}
	Uncompute(res, 0, anc, 5, 4, 3){
		Toffoli( anc[2], anc[3], q[2] );
	} Free(anc, 5) {}
}
// Function 7 with degree 0
// nq: 4, na: 5, ng: 1
void func7R(qbit **q, int n) {
printf("func7R\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[1]; // interacting bits
	qbit *res[2];
	nb[0] = q[2];
	res[0] = q[3];
	res[1] = q[0];
	// Leaf function
	_computeModule(0, 5, 4, 3, 0, 2, 0);
	acquire(5, anc, 1, nb);
	Recompute (res, 0, anc, 5, 4, 3){
		Toffoli( anc[2], anc[3], q[2] );
	}
	Restore {
		CNOT( anc[1], res[0] );
		CNOT( anc[1], res[1] );
	}
	Unrecompute {
		Toffoli( anc[2], anc[3], q[2] );
	} Refree(anc, 5) {}
}
// Function 6 with degree 1
// nq: 3, na: 2, ng: 3
void func6(qbit **q, int n) {
printf("func6\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[8]; // interacting bits
	qbit *res[2];
	qbit *nq0[5];
	nb[0] = q[0];
	nb[1] = q[2];
	nb[2] = q[1];
	nb[3] = q[1];
	nb[4] = q[2];
	nb[5] = q[0];
	nb[6] = q[2];
	nb[7] = q[1];
	res[0] = q[0];
	res[1] = q[2];
	// Non-leaf function
	Compute (0, 2, 8, 5, 1, 3, 0){
		acquire(2, anc, 8, nb);
	nq0[0] = q[2];
	nq0[1] = anc[0];
	nq0[2] = q[1];
	nq0[3] = q[0];
	nq0[4] = anc[1];
		Toffoli( q[0], q[2], q[1] );
		Toffoli( q[1], q[2], q[0] );
		func14(nq0, 5);
		Toffoli( anc[0], q[2], q[1] );
	}
	Store {
		CNOT( anc[0], res[0] );
		CNOT( anc[0], res[1] );
	}
	Uncompute(res, 0, anc, 2, 8, 5){
		Toffoli( anc[0], q[2], q[1] );
		func14R(nq0, 5);
		Toffoli( q[1], q[2], q[0] );
		Toffoli( q[0], q[2], q[1] );
	} Free(anc, 2) {}
}
// Function 6 with degree 1
// nq: 3, na: 2, ng: 3
void func6R(qbit **q, int n) {
printf("func6R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[8]; // interacting bits
	qbit *res[2];
	qbit *nq0[5];
	nb[0] = q[0];
	nb[1] = q[2];
	nb[2] = q[1];
	nb[3] = q[1];
	nb[4] = q[2];
	nb[5] = q[0];
	nb[6] = q[2];
	nb[7] = q[1];
	res[0] = q[0];
	res[1] = q[2];
	// Non-leaf function
	_computeModule(0, 2, 8, 5, 1, 3, 0);
	acquire(2, anc, 8, nb);
	nq0[0] = q[2];
	nq0[1] = anc[0];
	nq0[2] = q[1];
	nq0[3] = q[0];
	nq0[4] = anc[1];
	Recompute(res, 0, anc, 2, 8, 5){
		Toffoli( q[0], q[2], q[1] );
		Toffoli( q[1], q[2], q[0] );
		func14(nq0, 5);
		Toffoli( anc[0], q[2], q[1] );
	}
	Restore {
		CNOT( anc[0], res[0] );
		CNOT( anc[0], res[1] );
	}
	Unrecompute {
		Toffoli( anc[0], q[2], q[1] );
		func14R(nq0, 5);
		Toffoli( q[1], q[2], q[0] );
		Toffoli( q[0], q[2], q[1] );
	} Refree(anc, 2) {}
}
// Function 5 with degree 3
// nq: 3, na: 1, ng: 8
void func5(qbit **q, int n) {
printf("func5\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[15]; // interacting bits
	qbit *res[1];
	qbit *nq0[1];
	qbit *nq1[1];
	qbit *nq2[1];
	nb[0] = q[2];
	nb[1] = q[1];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[1];
	nb[5] = q[2];
	nb[6] = q[0];
	nb[7] = q[1];
	nb[8] = q[2];
	nb[9] = q[1];
	nb[10] = q[0];
	nb[11] = q[2];
	nb[12] = q[0];
	nb[13] = q[0];
	nb[14] = q[2];
	res[0] = q[0];
	// Non-leaf function
	Compute (0, 1, 17, 9, 3, 3, 0){
		acquire(1, anc, 15, nb);
	nq0[0] = q[2];
	nq1[0] = anc[0];
	nq2[0] = q[0];
		CNOT( anc[0], q[0] );
		Toffoli( q[1], anc[0], q[0] );
		func12(nq1, 1);
		CNOT( anc[0], q[1] );
		func11(nq0, 1);
		Toffoli( q[0], anc[0], q[2] );
		func13(nq2, 1);
		CNOT( anc[0], q[2] );
		Toffoli( q[2], q[1], anc[0] );
		Toffoli( q[0], q[1], q[2] );
		Toffoli( q[0], q[1], q[2] );
	}
	Store {
		CNOT( anc[0], res[0] );
	}
	Uncompute(res, 0, anc, 1, 17, 9){
		Toffoli( q[0], q[1], q[2] );
		Toffoli( q[0], q[1], q[2] );
		Toffoli( q[2], q[1], anc[0] );
		CNOT( anc[0], q[2] );
		func13R(nq2, 1);
		Toffoli( q[0], anc[0], q[2] );
		func11R(nq0, 1);
		CNOT( anc[0], q[1] );
		func12R(nq1, 1);
		Toffoli( q[1], anc[0], q[0] );
		CNOT( anc[0], q[0] );
	} Free(anc, 1) {}
}
// Function 5 with degree 3
// nq: 3, na: 1, ng: 8
void func5R(qbit **q, int n) {
printf("func5R\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[15]; // interacting bits
	qbit *res[1];
	qbit *nq0[1];
	qbit *nq1[1];
	qbit *nq2[1];
	nb[0] = q[2];
	nb[1] = q[1];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[1];
	nb[5] = q[2];
	nb[6] = q[0];
	nb[7] = q[1];
	nb[8] = q[2];
	nb[9] = q[1];
	nb[10] = q[0];
	nb[11] = q[2];
	nb[12] = q[0];
	nb[13] = q[0];
	nb[14] = q[2];
	res[0] = q[0];
	// Non-leaf function
	_computeModule(0, 1, 17, 9, 3, 3, 0);
	acquire(1, anc, 15, nb);
	nq0[0] = q[2];
	nq1[0] = anc[0];
	nq2[0] = q[0];
	Recompute(res, 0, anc, 1, 17, 9){
		CNOT( anc[0], q[0] );
		Toffoli( q[1], anc[0], q[0] );
		func12(nq1, 1);
		CNOT( anc[0], q[1] );
		func11(nq0, 1);
		Toffoli( q[0], anc[0], q[2] );
		func13(nq2, 1);
		CNOT( anc[0], q[2] );
		Toffoli( q[2], q[1], anc[0] );
		Toffoli( q[0], q[1], q[2] );
		Toffoli( q[0], q[1], q[2] );
	}
	Restore {
		CNOT( anc[0], res[0] );
	}
	Unrecompute {
		Toffoli( q[0], q[1], q[2] );
		Toffoli( q[0], q[1], q[2] );
		Toffoli( q[2], q[1], anc[0] );
		CNOT( anc[0], q[2] );
		func13R(nq2, 1);
		Toffoli( q[0], anc[0], q[2] );
		func11R(nq0, 1);
		CNOT( anc[0], q[1] );
		func12R(nq1, 1);
		Toffoli( q[1], anc[0], q[0] );
		CNOT( anc[0], q[0] );
	} Refree(anc, 1) {}
}
// Function 4 with degree 2
// nq: 3, na: 5, ng: 5
void func4(qbit **q, int n) {
printf("func4\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[1];
	qbit *nq0[4];
	qbit *nq1[4];
	nb[0] = q[1];
	nb[1] = q[0];
	res[0] = q[1];
	// Non-leaf function
	Compute (0, 5, 11, 6, 2, 3, 0){
		acquire(5, anc, 2, nb);
	nq0[0] = anc[2];
	nq0[1] = anc[3];
	nq0[2] = q[0];
	nq0[3] = anc[1];
	nq1[0] = anc[4];
	nq1[1] = anc[0];
	nq1[2] = q[2];
	nq1[3] = q[1];
		func10(nq1, 4);
		CNOT( anc[2], q[1] );
		func9(nq0, 4);
		CNOT( q[0], anc[3] );
		CNOT( anc[2], anc[1] );
		CNOT( anc[1], anc[0] );
		CNOT( anc[2], anc[3] );
	}
	Store {
		CNOT( q[0], res[0] );
	}
	Uncompute(res, 0, anc, 5, 11, 6){
		CNOT( anc[2], anc[3] );
		CNOT( anc[1], anc[0] );
		CNOT( anc[2], anc[1] );
		CNOT( q[0], anc[3] );
		func9R(nq0, 4);
		CNOT( anc[2], q[1] );
		func10R(nq1, 4);
	} Free(anc, 5) {}
}
// Function 4 with degree 2
// nq: 3, na: 5, ng: 5
void func4R(qbit **q, int n) {
printf("func4R\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[1];
	qbit *nq0[4];
	qbit *nq1[4];
	nb[0] = q[1];
	nb[1] = q[0];
	res[0] = q[1];
	// Non-leaf function
	_computeModule(0, 5, 11, 6, 2, 3, 0);
	acquire(5, anc, 2, nb);
	nq0[0] = anc[2];
	nq0[1] = anc[3];
	nq0[2] = q[0];
	nq0[3] = anc[1];
	nq1[0] = anc[4];
	nq1[1] = anc[0];
	nq1[2] = q[2];
	nq1[3] = q[1];
	Recompute(res, 0, anc, 5, 11, 6){
		func10(nq1, 4);
		CNOT( anc[2], q[1] );
		func9(nq0, 4);
		CNOT( q[0], anc[3] );
		CNOT( anc[2], anc[1] );
		CNOT( anc[1], anc[0] );
		CNOT( anc[2], anc[3] );
	}
	Restore {
		CNOT( q[0], res[0] );
	}
	Unrecompute {
		CNOT( anc[2], anc[3] );
		CNOT( anc[1], anc[0] );
		CNOT( anc[2], anc[1] );
		CNOT( q[0], anc[3] );
		func9R(nq0, 4);
		CNOT( anc[2], q[1] );
		func10R(nq1, 4);
	} Refree(anc, 5) {}
}
// Function 3 with degree 0
// nq: 5, na: 5, ng: 5
void func3(qbit **q, int n) {
printf("func3\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[2];
	nb[0] = q[4];
	nb[1] = q[3];
	nb[2] = q[4];
	nb[3] = q[2];
	nb[4] = q[2];
	nb[5] = q[4];
	res[0] = q[2];
	res[1] = q[4];
	// Leaf function
	Compute (0, 5, 12, 7, 0, 96, 0) {
		acquire(5, anc, 6, nb);
		Toffoli( anc[2], anc[0], q[4] );
		CNOT( q[3], anc[2] );
		Toffoli( anc[1], q[4], q[2] );
		CNOT( q[2], anc[2] );
		CNOT( anc[4], q[4] );
	}
	Store {
		CNOT( q[1], res[0] );
		CNOT( anc[3], res[1] );
	}
	Uncompute(res, 0, anc, 5, 12, 7){
		CNOT( anc[4], q[4] );
		CNOT( q[2], anc[2] );
		Toffoli( anc[1], q[4], q[2] );
		CNOT( q[3], anc[2] );
		Toffoli( anc[2], anc[0], q[4] );
	} Free(anc, 5) {}
}
// Function 3 with degree 0
// nq: 5, na: 5, ng: 5
void func3R(qbit **q, int n) {
printf("func3R\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[2];
	nb[0] = q[4];
	nb[1] = q[3];
	nb[2] = q[4];
	nb[3] = q[2];
	nb[4] = q[2];
	nb[5] = q[4];
	res[0] = q[2];
	res[1] = q[4];
	// Leaf function
	_computeModule(0, 5, 12, 7, 0, 96, 0);
	acquire(5, anc, 6, nb);
	Recompute (res, 0, anc, 5, 12, 7){
		CNOT( anc[4], q[4] );
		CNOT( q[2], anc[2] );
		Toffoli( anc[1], q[4], q[2] );
		CNOT( q[3], anc[2] );
		Toffoli( anc[2], anc[0], q[4] );
	}
	Restore {
		CNOT( q[1], res[0] );
		CNOT( anc[3], res[1] );
	}
	Unrecompute {
		Toffoli( anc[2], anc[0], q[4] );
		CNOT( q[3], anc[2] );
		Toffoli( anc[1], q[4], q[2] );
		CNOT( q[2], anc[2] );
		CNOT( anc[4], q[4] );
	} Refree(anc, 5) {}
}
// Function 2 with degree 2
// nq: 5, na: 3, ng: 7
void func2(qbit **q, int n) {
printf("func2\n");
fflush(stderr);
	qbit *anc[3]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[1];
	qbit *nq0[4];
	qbit *nq1[4];
	nb[0] = q[4];
	nb[1] = q[3];
	nb[2] = q[3];
	nb[3] = q[0];
	nb[4] = q[1];
	nb[5] = q[2];
	res[0] = q[2];
	// Non-leaf function
	Compute (0, 3, 15, 8, 2, 96, 0){
		acquire(3, anc, 6, nb);
	nq0[0] = anc[0];
	nq0[1] = q[1];
	nq0[2] = q[0];
	nq0[3] = anc[1];
	nq1[0] = anc[2];
	nq1[1] = q[4];
	nq1[2] = q[3];
	nq1[3] = q[2];
		Toffoli( q[2], anc[2], anc[0] );
		Toffoli( anc[1], anc[0], anc[2] );
		Toffoli( q[0], q[1], anc[2] );
		func7(nq0, 4);
		CNOT( anc[2], q[3] );
		CNOT( anc[2], q[4] );
		CNOT( anc[1], anc[0] );
		func8(nq1, 4);
		CNOT( q[3], anc[2] );
	}
	Store {
		CNOT( q[0], res[0] );
	}
	Uncompute(res, 0, anc, 3, 15, 8){
		CNOT( q[3], anc[2] );
		func8R(nq1, 4);
		CNOT( anc[1], anc[0] );
		CNOT( anc[2], q[4] );
		CNOT( anc[2], q[3] );
		func7R(nq0, 4);
		Toffoli( q[0], q[1], anc[2] );
		Toffoli( anc[1], anc[0], anc[2] );
		Toffoli( q[2], anc[2], anc[0] );
	} Free(anc, 3) {}
}
// Function 2 with degree 2
// nq: 5, na: 3, ng: 7
void func2R(qbit **q, int n) {
printf("func2R\n");
fflush(stderr);
	qbit *anc[3]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[1];
	qbit *nq0[4];
	qbit *nq1[4];
	nb[0] = q[4];
	nb[1] = q[3];
	nb[2] = q[3];
	nb[3] = q[0];
	nb[4] = q[1];
	nb[5] = q[2];
	res[0] = q[2];
	// Non-leaf function
	_computeModule(0, 3, 15, 8, 2, 96, 0);
	acquire(3, anc, 6, nb);
	nq0[0] = anc[0];
	nq0[1] = q[1];
	nq0[2] = q[0];
	nq0[3] = anc[1];
	nq1[0] = anc[2];
	nq1[1] = q[4];
	nq1[2] = q[3];
	nq1[3] = q[2];
	Recompute(res, 0, anc, 3, 15, 8){
		Toffoli( q[2], anc[2], anc[0] );
		Toffoli( anc[1], anc[0], anc[2] );
		Toffoli( q[0], q[1], anc[2] );
		func7(nq0, 4);
		CNOT( anc[2], q[3] );
		CNOT( anc[2], q[4] );
		CNOT( anc[1], anc[0] );
		func8(nq1, 4);
		CNOT( q[3], anc[2] );
	}
	Restore {
		CNOT( q[0], res[0] );
	}
	Unrecompute {
		CNOT( q[3], anc[2] );
		func8R(nq1, 4);
		CNOT( anc[1], anc[0] );
		CNOT( anc[2], q[4] );
		CNOT( anc[2], q[3] );
		func7R(nq0, 4);
		Toffoli( q[0], q[1], anc[2] );
		Toffoli( anc[1], anc[0], anc[2] );
		Toffoli( q[2], anc[2], anc[0] );
	} Refree(anc, 3) {}
}
// Function 1 with degree 3
// nq: 5, na: 5, ng: 5
void func1(qbit **q, int n) {
printf("func1\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[4];
	qbit *nq0[3];
	qbit *nq1[3];
	qbit *nq2[3];
	nb[0] = q[4];
	nb[1] = q[0];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[1];
	nb[5] = q[0];
	nb[6] = q[4];
	nb[7] = q[4];
	nb[8] = q[1];
	res[0] = q[4];
	res[1] = q[3];
	res[2] = q[0];
	res[3] = q[1];
	// Non-leaf function
	Compute (0, 5, 14, 9, 3, 96, 0){
		acquire(5, anc, 9, nb);
	nq0[0] = q[1];
	nq0[1] = q[2];
	nq0[2] = anc[4];
	nq1[0] = q[0];
	nq1[1] = anc[3];
	nq1[2] = anc[1];
	nq2[0] = anc[2];
	nq2[1] = q[4];
	nq2[2] = q[3];
		func6(nq2, 3);
		func4(nq0, 3);
		CNOT( anc[3], q[4] );
		CNOT( q[0], q[1] );
		func5(nq1, 3);
		Toffoli( q[4], q[1], anc[0] );
		Toffoli( q[0], q[1], anc[4] );
		CNOT( q[0], q[4] );
	}
	Store {
		CNOT( q[2], res[0] );
		CNOT( anc[4], res[1] );
		CNOT( anc[2], res[2] );
		CNOT( anc[1], res[3] );
	}
	Uncompute(res, 0, anc, 5, 14, 9){
		CNOT( q[0], q[4] );
		Toffoli( q[0], q[1], anc[4] );
		Toffoli( q[4], q[1], anc[0] );
		func5R(nq1, 3);
		CNOT( q[0], q[1] );
		CNOT( anc[3], q[4] );
		func4R(nq0, 3);
		func6R(nq2, 3);
	} Free(anc, 5) {}
}
// Function 1 with degree 3
// nq: 5, na: 5, ng: 5
void func1R(qbit **q, int n) {
printf("func1R\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[4];
	qbit *nq0[3];
	qbit *nq1[3];
	qbit *nq2[3];
	nb[0] = q[4];
	nb[1] = q[0];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[1];
	nb[5] = q[0];
	nb[6] = q[4];
	nb[7] = q[4];
	nb[8] = q[1];
	res[0] = q[4];
	res[1] = q[3];
	res[2] = q[0];
	res[3] = q[1];
	// Non-leaf function
	_computeModule(0, 5, 14, 9, 3, 96, 0);
	acquire(5, anc, 9, nb);
	nq0[0] = q[1];
	nq0[1] = q[2];
	nq0[2] = anc[4];
	nq1[0] = q[0];
	nq1[1] = anc[3];
	nq1[2] = anc[1];
	nq2[0] = anc[2];
	nq2[1] = q[4];
	nq2[2] = q[3];
	Recompute(res, 0, anc, 5, 14, 9){
		func6(nq2, 3);
		func4(nq0, 3);
		CNOT( anc[3], q[4] );
		CNOT( q[0], q[1] );
		func5(nq1, 3);
		Toffoli( q[4], q[1], anc[0] );
		Toffoli( q[0], q[1], anc[4] );
		CNOT( q[0], q[4] );
	}
	Restore {
		CNOT( q[2], res[0] );
		CNOT( anc[4], res[1] );
		CNOT( anc[2], res[2] );
		CNOT( anc[1], res[3] );
	}
	Unrecompute {
		CNOT( q[0], q[4] );
		Toffoli( q[0], q[1], anc[4] );
		Toffoli( q[4], q[1], anc[0] );
		func5R(nq1, 3);
		CNOT( q[0], q[1] );
		CNOT( anc[3], q[4] );
		func4R(nq0, 3);
		func6R(nq2, 3);
	} Refree(anc, 5) {}
}
// main function
int main() {
	qbit *new[16];
	acquire(16, new, 0, NULL);
	// Intialize inputs
	X (new[12]);
	X (new[13]);
	X (new[9]);
	X (new[1]);
	X (new[3]);
	X (new[5]);
	X (new[10]);
	X (new[0]);
	X (new[15]);
	// Start computation
	qbit *nq0[5];
	qbit *nq1[5];
	qbit *nq2[5];
	nq0[0] = new[12];
	nq0[1] = new[4];
	nq0[2] = new[10];
	nq0[3] = new[0];
	nq0[4] = new[6];
	nq1[0] = new[7];
	nq1[1] = new[1];
	nq1[2] = new[8];
	nq1[3] = new[15];
	nq1[4] = new[2];
	nq2[0] = new[13];
	nq2[1] = new[9];
	nq2[2] = new[3];
	nq2[3] = new[14];
	nq2[4] = new[5];
	for (int i = 0; i < LOOP; i++) {
		func1(nq0, 5);
		func2(nq1, 5);
		func3(nq2, 5);
	}
	return 0;
}
