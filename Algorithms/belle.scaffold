// Scaffold file synthesized by para-bench.py
// qubits: 128 ancilla: 8 gates: 8 levels: 4 degrees: 3 loops: 32
#include "qalloc.h"
#include "uncompute.h"
#define LOOP 32
// Call list: 1,2,3;4,5,6;7,8;;9,10;11,12,13;14;;15;16;17,18,19;;20,21,22;23,24;25,26;27,28;
// Function 28 with degree 0
// nq: 19, na: 5, ng: 6
void func28(qbit **q, int n) {
printf("func28\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[12];
	nb[0] = q[15];
	nb[1] = q[13];
	nb[2] = q[10];
	nb[3] = q[18];
	nb[4] = q[18];
	nb[5] = q[13];
	nb[6] = q[17];
	nb[7] = q[7];
	nb[8] = q[8];
	res[0] = q[8];
	res[1] = q[17];
	res[2] = q[0];
	res[3] = q[18];
	res[4] = q[5];
	res[5] = q[10];
	res[6] = q[7];
	res[7] = q[1];
	res[8] = q[16];
	res[9] = q[2];
	res[10] = q[3];
	res[11] = q[15];
	// Leaf function
	Compute (0, 5, 24, 18, 0, 2, 0) {
		acquire(5, anc, 9, nb);
		CNOT( q[15], q[13] );
		CNOT( q[10], anc[2] );
		CNOT( anc[4], q[18] );
		CNOT( q[18], q[13] );
		CNOT( anc[1], anc[2] );
		Toffoli( q[17], q[7], q[8] );
	}
	Store {
		CNOT( q[10], res[0] );
		CNOT( anc[1], res[1] );
		CNOT( q[18], res[2] );
		CNOT( q[16], res[3] );
		CNOT( q[6], res[4] );
		CNOT( q[4], res[5] );
		CNOT( q[12], res[6] );
		CNOT( q[0], res[7] );
		CNOT( anc[3], res[8] );
		CNOT( q[7], res[9] );
		CNOT( q[1], res[10] );
		CNOT( anc[0], res[11] );
	}
	Uncompute(res, 0, anc, 5, 24, 18){
		Toffoli( q[17], q[7], q[8] );
		CNOT( anc[1], anc[2] );
		CNOT( q[18], q[13] );
		CNOT( anc[4], q[18] );
		CNOT( q[10], anc[2] );
		CNOT( q[15], q[13] );
	} Free(anc, 5) {}
}
// Function 28 with degree 0
// nq: 19, na: 5, ng: 6
void func28R(qbit **q, int n) {
printf("func28R\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[12];
	nb[0] = q[15];
	nb[1] = q[13];
	nb[2] = q[10];
	nb[3] = q[18];
	nb[4] = q[18];
	nb[5] = q[13];
	nb[6] = q[17];
	nb[7] = q[7];
	nb[8] = q[8];
	res[0] = q[8];
	res[1] = q[17];
	res[2] = q[0];
	res[3] = q[18];
	res[4] = q[5];
	res[5] = q[10];
	res[6] = q[7];
	res[7] = q[1];
	res[8] = q[16];
	res[9] = q[2];
	res[10] = q[3];
	res[11] = q[15];
	// Leaf function
	_computeModule(0, 5, 24, 18, 0, 2, 0);
	acquire(5, anc, 9, nb);
	Recompute (res, 0, anc, 5, 24, 18){
		Toffoli( q[17], q[7], q[8] );
		CNOT( anc[1], anc[2] );
		CNOT( q[18], q[13] );
		CNOT( anc[4], q[18] );
		CNOT( q[10], anc[2] );
		CNOT( q[15], q[13] );
	}
	Restore {
		CNOT( q[10], res[0] );
		CNOT( anc[1], res[1] );
		CNOT( q[18], res[2] );
		CNOT( q[16], res[3] );
		CNOT( q[6], res[4] );
		CNOT( q[4], res[5] );
		CNOT( q[12], res[6] );
		CNOT( q[0], res[7] );
		CNOT( anc[3], res[8] );
		CNOT( q[7], res[9] );
		CNOT( q[1], res[10] );
		CNOT( anc[0], res[11] );
	}
	Unrecompute {
		CNOT( q[15], q[13] );
		CNOT( q[10], anc[2] );
		CNOT( anc[4], q[18] );
		CNOT( q[18], q[13] );
		CNOT( anc[1], anc[2] );
		Toffoli( q[17], q[7], q[8] );
	} Refree(anc, 5) {}
}
// Function 27 with degree 0
// nq: 19, na: 1, ng: 4
void func27(qbit **q, int n) {
printf("func27\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[17];
	nb[0] = q[7];
	nb[1] = q[8];
	nb[2] = q[3];
	nb[3] = q[10];
	nb[4] = q[1];
	nb[5] = q[12];
	nb[6] = q[3];
	nb[7] = q[8];
	nb[8] = q[5];
	res[0] = q[5];
	res[1] = q[13];
	res[2] = q[6];
	res[3] = q[7];
	res[4] = q[15];
	res[5] = q[3];
	res[6] = q[1];
	res[7] = q[14];
	res[8] = q[18];
	res[9] = q[9];
	res[10] = q[11];
	res[11] = q[4];
	res[12] = q[0];
	res[13] = q[16];
	res[14] = q[17];
	res[15] = q[2];
	res[16] = q[12];
	// Leaf function
	Compute (0, 1, 25, 21, 0, 2, 0) {
		acquire(1, anc, 9, nb);
		CNOT( q[7], q[8] );
		CNOT( q[3], q[10] );
		Toffoli( q[1], q[12], q[3] );
		CNOT( q[8], q[5] );
	}
	Store {
		CNOT( q[1], res[0] );
		CNOT( q[18], res[1] );
		CNOT( q[9], res[2] );
		CNOT( q[17], res[3] );
		CNOT( anc[0], res[4] );
		CNOT( q[13], res[5] );
		CNOT( q[12], res[6] );
		CNOT( q[8], res[7] );
		CNOT( q[0], res[8] );
		CNOT( q[4], res[9] );
		CNOT( q[16], res[10] );
		CNOT( q[5], res[11] );
		CNOT( q[6], res[12] );
		CNOT( q[14], res[13] );
		CNOT( q[7], res[14] );
		CNOT( q[15], res[15] );
		CNOT( q[10], res[16] );
	}
	Uncompute(res, 0, anc, 1, 25, 21){
		CNOT( q[8], q[5] );
		Toffoli( q[1], q[12], q[3] );
		CNOT( q[3], q[10] );
		CNOT( q[7], q[8] );
	} Free(anc, 1) {}
}
// Function 27 with degree 0
// nq: 19, na: 1, ng: 4
void func27R(qbit **q, int n) {
printf("func27R\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[17];
	nb[0] = q[7];
	nb[1] = q[8];
	nb[2] = q[3];
	nb[3] = q[10];
	nb[4] = q[1];
	nb[5] = q[12];
	nb[6] = q[3];
	nb[7] = q[8];
	nb[8] = q[5];
	res[0] = q[5];
	res[1] = q[13];
	res[2] = q[6];
	res[3] = q[7];
	res[4] = q[15];
	res[5] = q[3];
	res[6] = q[1];
	res[7] = q[14];
	res[8] = q[18];
	res[9] = q[9];
	res[10] = q[11];
	res[11] = q[4];
	res[12] = q[0];
	res[13] = q[16];
	res[14] = q[17];
	res[15] = q[2];
	res[16] = q[12];
	// Leaf function
	_computeModule(0, 1, 25, 21, 0, 2, 0);
	acquire(1, anc, 9, nb);
	Recompute (res, 0, anc, 1, 25, 21){
		CNOT( q[8], q[5] );
		Toffoli( q[1], q[12], q[3] );
		CNOT( q[3], q[10] );
		CNOT( q[7], q[8] );
	}
	Restore {
		CNOT( q[1], res[0] );
		CNOT( q[18], res[1] );
		CNOT( q[9], res[2] );
		CNOT( q[17], res[3] );
		CNOT( anc[0], res[4] );
		CNOT( q[13], res[5] );
		CNOT( q[12], res[6] );
		CNOT( q[8], res[7] );
		CNOT( q[0], res[8] );
		CNOT( q[4], res[9] );
		CNOT( q[16], res[10] );
		CNOT( q[5], res[11] );
		CNOT( q[6], res[12] );
		CNOT( q[14], res[13] );
		CNOT( q[7], res[14] );
		CNOT( q[15], res[15] );
		CNOT( q[10], res[16] );
	}
	Unrecompute {
		CNOT( q[7], q[8] );
		CNOT( q[3], q[10] );
		Toffoli( q[1], q[12], q[3] );
		CNOT( q[8], q[5] );
	} Refree(anc, 1) {}
}
// Function 26 with degree 0
// nq: 9, na: 5, ng: 6
void func26(qbit **q, int n) {
printf("func26\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[8]; // interacting bits
	qbit *res[7];
	nb[0] = q[0];
	nb[1] = q[4];
	nb[2] = q[2];
	nb[3] = q[4];
	nb[4] = q[1];
	nb[5] = q[6];
	nb[6] = q[8];
	nb[7] = q[7];
	res[0] = q[7];
	res[1] = q[0];
	res[2] = q[2];
	res[3] = q[5];
	res[4] = q[3];
	res[5] = q[4];
	res[6] = q[6];
	// Leaf function
	Compute (0, 5, 19, 13, 0, 2, 0) {
		acquire(5, anc, 8, nb);
		Toffoli( q[0], anc[2], q[4] );
		CNOT( anc[1], anc[3] );
		CNOT( anc[0], q[2] );
		Toffoli( q[4], anc[0], q[1] );
		CNOT( q[6], anc[2] );
		Toffoli( q[8], anc[1], q[7] );
	}
	Store {
		CNOT( anc[4], res[0] );
		CNOT( q[5], res[1] );
		CNOT( anc[2], res[2] );
		CNOT( q[2], res[3] );
		CNOT( anc[3], res[4] );
		CNOT( q[0], res[5] );
		CNOT( anc[3], res[6] );
	}
	Uncompute(res, 0, anc, 5, 19, 13){
		Toffoli( q[8], anc[1], q[7] );
		CNOT( q[6], anc[2] );
		Toffoli( q[4], anc[0], q[1] );
		CNOT( anc[0], q[2] );
		CNOT( anc[1], anc[3] );
		Toffoli( q[0], anc[2], q[4] );
	} Free(anc, 5) {}
}
// Function 26 with degree 0
// nq: 9, na: 5, ng: 6
void func26R(qbit **q, int n) {
printf("func26R\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[8]; // interacting bits
	qbit *res[7];
	nb[0] = q[0];
	nb[1] = q[4];
	nb[2] = q[2];
	nb[3] = q[4];
	nb[4] = q[1];
	nb[5] = q[6];
	nb[6] = q[8];
	nb[7] = q[7];
	res[0] = q[7];
	res[1] = q[0];
	res[2] = q[2];
	res[3] = q[5];
	res[4] = q[3];
	res[5] = q[4];
	res[6] = q[6];
	// Leaf function
	_computeModule(0, 5, 19, 13, 0, 2, 0);
	acquire(5, anc, 8, nb);
	Recompute (res, 0, anc, 5, 19, 13){
		Toffoli( q[8], anc[1], q[7] );
		CNOT( q[6], anc[2] );
		Toffoli( q[4], anc[0], q[1] );
		CNOT( anc[0], q[2] );
		CNOT( anc[1], anc[3] );
		Toffoli( q[0], anc[2], q[4] );
	}
	Restore {
		CNOT( anc[4], res[0] );
		CNOT( q[5], res[1] );
		CNOT( anc[2], res[2] );
		CNOT( q[2], res[3] );
		CNOT( anc[3], res[4] );
		CNOT( q[0], res[5] );
		CNOT( anc[3], res[6] );
	}
	Unrecompute {
		Toffoli( q[0], anc[2], q[4] );
		CNOT( anc[1], anc[3] );
		CNOT( anc[0], q[2] );
		Toffoli( q[4], anc[0], q[1] );
		CNOT( q[6], anc[2] );
		Toffoli( q[8], anc[1], q[7] );
	} Refree(anc, 5) {}
}
// Function 25 with degree 0
// nq: 9, na: 1, ng: 7
void func25(qbit **q, int n) {
printf("func25\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[16]; // interacting bits
	qbit *res[5];
	nb[0] = q[2];
	nb[1] = q[7];
	nb[2] = q[7];
	nb[3] = q[5];
	nb[4] = q[1];
	nb[5] = q[7];
	nb[6] = q[6];
	nb[7] = q[0];
	nb[8] = q[3];
	nb[9] = q[1];
	nb[10] = q[5];
	nb[11] = q[0];
	nb[12] = q[8];
	nb[13] = q[4];
	nb[14] = q[6];
	nb[15] = q[8];
	res[0] = q[2];
	res[1] = q[5];
	res[2] = q[1];
	res[3] = q[6];
	res[4] = q[7];
	// Leaf function
	Compute (0, 1, 19, 12, 0, 2, 0) {
		acquire(1, anc, 16, nb);
		Toffoli( q[2], q[7], anc[0] );
		Toffoli( q[7], q[5], anc[0] );
		Toffoli( q[1], q[7], q[6] );
		CNOT( anc[0], q[0] );
		Toffoli( q[3], q[1], q[5] );
		CNOT( q[0], q[8] );
		Toffoli( q[4], q[6], q[8] );
	}
	Store {
		CNOT( q[3], res[0] );
		CNOT( q[1], res[1] );
		CNOT( q[5], res[2] );
		CNOT( anc[0], res[3] );
		CNOT( anc[0], res[4] );
	}
	Uncompute(res, 0, anc, 1, 19, 12){
		Toffoli( q[4], q[6], q[8] );
		CNOT( q[0], q[8] );
		Toffoli( q[3], q[1], q[5] );
		CNOT( anc[0], q[0] );
		Toffoli( q[1], q[7], q[6] );
		Toffoli( q[7], q[5], anc[0] );
		Toffoli( q[2], q[7], anc[0] );
	} Free(anc, 1) {}
}
// Function 25 with degree 0
// nq: 9, na: 1, ng: 7
void func25R(qbit **q, int n) {
printf("func25R\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[16]; // interacting bits
	qbit *res[5];
	nb[0] = q[2];
	nb[1] = q[7];
	nb[2] = q[7];
	nb[3] = q[5];
	nb[4] = q[1];
	nb[5] = q[7];
	nb[6] = q[6];
	nb[7] = q[0];
	nb[8] = q[3];
	nb[9] = q[1];
	nb[10] = q[5];
	nb[11] = q[0];
	nb[12] = q[8];
	nb[13] = q[4];
	nb[14] = q[6];
	nb[15] = q[8];
	res[0] = q[2];
	res[1] = q[5];
	res[2] = q[1];
	res[3] = q[6];
	res[4] = q[7];
	// Leaf function
	_computeModule(0, 1, 19, 12, 0, 2, 0);
	acquire(1, anc, 16, nb);
	Recompute (res, 0, anc, 1, 19, 12){
		Toffoli( q[4], q[6], q[8] );
		CNOT( q[0], q[8] );
		Toffoli( q[3], q[1], q[5] );
		CNOT( anc[0], q[0] );
		Toffoli( q[1], q[7], q[6] );
		Toffoli( q[7], q[5], anc[0] );
		Toffoli( q[2], q[7], anc[0] );
	}
	Restore {
		CNOT( q[3], res[0] );
		CNOT( q[1], res[1] );
		CNOT( q[5], res[2] );
		CNOT( anc[0], res[3] );
		CNOT( anc[0], res[4] );
	}
	Unrecompute {
		Toffoli( q[2], q[7], anc[0] );
		Toffoli( q[7], q[5], anc[0] );
		Toffoli( q[1], q[7], q[6] );
		CNOT( anc[0], q[0] );
		Toffoli( q[3], q[1], q[5] );
		CNOT( q[0], q[8] );
		Toffoli( q[4], q[6], q[8] );
	} Refree(anc, 1) {}
}
// Function 24 with degree 0
// nq: 7, na: 7, ng: 4
void func24(qbit **q, int n) {
printf("func24\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[7];
	nb[0] = q[0];
	nb[1] = q[5];
	nb[2] = q[6];
	nb[3] = q[3];
	nb[4] = q[4];
	nb[5] = q[2];
	res[0] = q[4];
	res[1] = q[0];
	res[2] = q[5];
	res[3] = q[3];
	res[4] = q[6];
	res[5] = q[2];
	res[6] = q[1];
	// Leaf function
	Compute (0, 7, 15, 11, 0, 2, 0) {
		acquire(7, anc, 6, nb);
		CNOT( q[0], anc[0] );
		CNOT( anc[5], q[5] );
		Toffoli( q[6], q[3], q[4] );
		Toffoli( q[2], anc[5], anc[4] );
	}
	Store {
		CNOT( q[6], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( anc[6], res[2] );
		CNOT( q[1], res[3] );
		CNOT( anc[4], res[4] );
		CNOT( anc[4], res[5] );
		CNOT( q[3], res[6] );
	}
	Uncompute(res, 0, anc, 7, 15, 11){
		Toffoli( q[2], anc[5], anc[4] );
		Toffoli( q[6], q[3], q[4] );
		CNOT( anc[5], q[5] );
		CNOT( q[0], anc[0] );
	} Free(anc, 7) {}
}
// Function 24 with degree 0
// nq: 7, na: 7, ng: 4
void func24R(qbit **q, int n) {
printf("func24R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[6]; // interacting bits
	qbit *res[7];
	nb[0] = q[0];
	nb[1] = q[5];
	nb[2] = q[6];
	nb[3] = q[3];
	nb[4] = q[4];
	nb[5] = q[2];
	res[0] = q[4];
	res[1] = q[0];
	res[2] = q[5];
	res[3] = q[3];
	res[4] = q[6];
	res[5] = q[2];
	res[6] = q[1];
	// Leaf function
	_computeModule(0, 7, 15, 11, 0, 2, 0);
	acquire(7, anc, 6, nb);
	Recompute (res, 0, anc, 7, 15, 11){
		Toffoli( q[2], anc[5], anc[4] );
		Toffoli( q[6], q[3], q[4] );
		CNOT( anc[5], q[5] );
		CNOT( q[0], anc[0] );
	}
	Restore {
		CNOT( q[6], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( anc[6], res[2] );
		CNOT( q[1], res[3] );
		CNOT( anc[4], res[4] );
		CNOT( anc[4], res[5] );
		CNOT( q[3], res[6] );
	}
	Unrecompute {
		CNOT( q[0], anc[0] );
		CNOT( anc[5], q[5] );
		Toffoli( q[6], q[3], q[4] );
		Toffoli( q[2], anc[5], anc[4] );
	} Refree(anc, 7) {}
}
// Function 23 with degree 0
// nq: 7, na: 6, ng: 3
void func23(qbit **q, int n) {
printf("func23\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[5]; // interacting bits
	qbit *res[3];
	nb[0] = q[1];
	nb[1] = q[3];
	nb[2] = q[3];
	nb[3] = q[5];
	nb[4] = q[3];
	res[0] = q[2];
	res[1] = q[1];
	res[2] = q[6];
	// Leaf function
	Compute (0, 6, 9, 6, 0, 2, 0) {
		acquire(6, anc, 5, nb);
		CNOT( q[1], q[3] );
		CNOT( q[3], anc[4] );
		Toffoli( q[5], q[3], anc[5] );
	}
	Store {
		CNOT( q[3], res[0] );
		CNOT( q[6], res[1] );
		CNOT( anc[4], res[2] );
	}
	Uncompute(res, 0, anc, 6, 9, 6){
		Toffoli( q[5], q[3], anc[5] );
		CNOT( q[3], anc[4] );
		CNOT( q[1], q[3] );
	} Free(anc, 6) {}
}
// Function 23 with degree 0
// nq: 7, na: 6, ng: 3
void func23R(qbit **q, int n) {
printf("func23R\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[5]; // interacting bits
	qbit *res[3];
	nb[0] = q[1];
	nb[1] = q[3];
	nb[2] = q[3];
	nb[3] = q[5];
	nb[4] = q[3];
	res[0] = q[2];
	res[1] = q[1];
	res[2] = q[6];
	// Leaf function
	_computeModule(0, 6, 9, 6, 0, 2, 0);
	acquire(6, anc, 5, nb);
	Recompute (res, 0, anc, 6, 9, 6){
		Toffoli( q[5], q[3], anc[5] );
		CNOT( q[3], anc[4] );
		CNOT( q[1], q[3] );
	}
	Restore {
		CNOT( q[3], res[0] );
		CNOT( q[6], res[1] );
		CNOT( anc[4], res[2] );
	}
	Unrecompute {
		CNOT( q[1], q[3] );
		CNOT( q[3], anc[4] );
		Toffoli( q[5], q[3], anc[5] );
	} Refree(anc, 6) {}
}
// Function 22 with degree 0
// nq: 3, na: 3, ng: 2
void func22(qbit **q, int n) {
printf("func22\n");
fflush(stderr);
	qbit *anc[3]; // ancilla
	qbit *nb[4]; // interacting bits
	qbit *res[1];
	nb[0] = q[2];
	nb[1] = q[1];
	nb[2] = q[0];
	nb[3] = q[2];
	res[0] = q[1];
	// Leaf function
	Compute (0, 3, 5, 3, 0, 3, 0) {
		acquire(3, anc, 4, nb);
		CNOT( q[2], q[1] );
		Toffoli( q[0], anc[0], q[2] );
	}
	Store {
		CNOT( anc[1], res[0] );
	}
	Uncompute(res, 0, anc, 3, 5, 3){
		Toffoli( q[0], anc[0], q[2] );
		CNOT( q[2], q[1] );
	} Free(anc, 3) {}
}
// Function 22 with degree 0
// nq: 3, na: 3, ng: 2
void func22R(qbit **q, int n) {
printf("func22R\n");
fflush(stderr);
	qbit *anc[3]; // ancilla
	qbit *nb[4]; // interacting bits
	qbit *res[1];
	nb[0] = q[2];
	nb[1] = q[1];
	nb[2] = q[0];
	nb[3] = q[2];
	res[0] = q[1];
	// Leaf function
	_computeModule(0, 3, 5, 3, 0, 3, 0);
	acquire(3, anc, 4, nb);
	Recompute (res, 0, anc, 3, 5, 3){
		Toffoli( q[0], anc[0], q[2] );
		CNOT( q[2], q[1] );
	}
	Restore {
		CNOT( anc[1], res[0] );
	}
	Unrecompute {
		CNOT( q[2], q[1] );
		Toffoli( q[0], anc[0], q[2] );
	} Refree(anc, 3) {}
}
// Function 21 with degree 0
// nq: 3, na: 1, ng: 8
void func21(qbit **q, int n) {
printf("func21\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[17]; // interacting bits
	qbit *res[3];
	nb[0] = q[0];
	nb[1] = q[2];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[0];
	nb[5] = q[2];
	nb[6] = q[2];
	nb[7] = q[1];
	nb[8] = q[2];
	nb[9] = q[1];
	nb[10] = q[1];
	nb[11] = q[2];
	nb[12] = q[0];
	nb[13] = q[0];
	nb[14] = q[1];
	nb[15] = q[0];
	nb[16] = q[1];
	res[0] = q[1];
	res[1] = q[0];
	res[2] = q[2];
	// Leaf function
	Compute (0, 1, 19, 11, 0, 3, 0) {
		acquire(1, anc, 17, nb);
		Toffoli( q[0], q[2], anc[0] );
		Toffoli( q[1], anc[0], q[0] );
		Toffoli( anc[0], q[0], q[2] );
		Toffoli( q[2], q[1], anc[0] );
		CNOT( q[2], q[1] );
		Toffoli( q[1], q[2], q[0] );
		Toffoli( q[0], anc[0], q[1] );
		Toffoli( q[0], q[1], anc[0] );
	}
	Store {
		CNOT( anc[0], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( q[0], res[2] );
	}
	Uncompute(res, 0, anc, 1, 19, 11){
		Toffoli( q[0], q[1], anc[0] );
		Toffoli( q[0], anc[0], q[1] );
		Toffoli( q[1], q[2], q[0] );
		CNOT( q[2], q[1] );
		Toffoli( q[2], q[1], anc[0] );
		Toffoli( anc[0], q[0], q[2] );
		Toffoli( q[1], anc[0], q[0] );
		Toffoli( q[0], q[2], anc[0] );
	} Free(anc, 1) {}
}
// Function 21 with degree 0
// nq: 3, na: 1, ng: 8
void func21R(qbit **q, int n) {
printf("func21R\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[17]; // interacting bits
	qbit *res[3];
	nb[0] = q[0];
	nb[1] = q[2];
	nb[2] = q[1];
	nb[3] = q[0];
	nb[4] = q[0];
	nb[5] = q[2];
	nb[6] = q[2];
	nb[7] = q[1];
	nb[8] = q[2];
	nb[9] = q[1];
	nb[10] = q[1];
	nb[11] = q[2];
	nb[12] = q[0];
	nb[13] = q[0];
	nb[14] = q[1];
	nb[15] = q[0];
	nb[16] = q[1];
	res[0] = q[1];
	res[1] = q[0];
	res[2] = q[2];
	// Leaf function
	_computeModule(0, 1, 19, 11, 0, 3, 0);
	acquire(1, anc, 17, nb);
	Recompute (res, 0, anc, 1, 19, 11){
		Toffoli( q[0], q[1], anc[0] );
		Toffoli( q[0], anc[0], q[1] );
		Toffoli( q[1], q[2], q[0] );
		CNOT( q[2], q[1] );
		Toffoli( q[2], q[1], anc[0] );
		Toffoli( anc[0], q[0], q[2] );
		Toffoli( q[1], anc[0], q[0] );
		Toffoli( q[0], q[2], anc[0] );
	}
	Restore {
		CNOT( anc[0], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( q[0], res[2] );
	}
	Unrecompute {
		Toffoli( q[0], q[2], anc[0] );
		Toffoli( q[1], anc[0], q[0] );
		Toffoli( anc[0], q[0], q[2] );
		Toffoli( q[2], q[1], anc[0] );
		CNOT( q[2], q[1] );
		Toffoli( q[1], q[2], q[0] );
		Toffoli( q[0], anc[0], q[1] );
		Toffoli( q[0], q[1], anc[0] );
	} Refree(anc, 1) {}
}
// Function 20 with degree 0
// nq: 3, na: 8, ng: 8
void func20(qbit **q, int n) {
printf("func20\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[5]; // interacting bits
	qbit *res[2];
	nb[0] = q[2];
	nb[1] = q[2];
	nb[2] = q[0];
	nb[3] = q[1];
	nb[4] = q[2];
	res[0] = q[1];
	res[1] = q[0];
	// Leaf function
	Compute (0, 8, 18, 10, 0, 3, 0) {
		acquire(8, anc, 5, nb);
		Toffoli( anc[1], anc[4], anc[5] );
		CNOT( anc[3], q[2] );
		CNOT( anc[5], anc[6] );
		Toffoli( anc[7], anc[0], q[2] );
		Toffoli( q[0], anc[0], anc[2] );
		CNOT( anc[6], q[1] );
		Toffoli( anc[1], anc[6], q[2] );
		Toffoli( anc[0], anc[3], anc[6] );
	}
	Store {
		CNOT( anc[4], res[0] );
		CNOT( q[2], res[1] );
	}
	Uncompute(res, 0, anc, 8, 18, 10){
		Toffoli( anc[0], anc[3], anc[6] );
		Toffoli( anc[1], anc[6], q[2] );
		CNOT( anc[6], q[1] );
		Toffoli( q[0], anc[0], anc[2] );
		Toffoli( anc[7], anc[0], q[2] );
		CNOT( anc[5], anc[6] );
		CNOT( anc[3], q[2] );
		Toffoli( anc[1], anc[4], anc[5] );
	} Free(anc, 8) {}
}
// Function 20 with degree 0
// nq: 3, na: 8, ng: 8
void func20R(qbit **q, int n) {
printf("func20R\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[5]; // interacting bits
	qbit *res[2];
	nb[0] = q[2];
	nb[1] = q[2];
	nb[2] = q[0];
	nb[3] = q[1];
	nb[4] = q[2];
	res[0] = q[1];
	res[1] = q[0];
	// Leaf function
	_computeModule(0, 8, 18, 10, 0, 3, 0);
	acquire(8, anc, 5, nb);
	Recompute (res, 0, anc, 8, 18, 10){
		Toffoli( anc[0], anc[3], anc[6] );
		Toffoli( anc[1], anc[6], q[2] );
		CNOT( anc[6], q[1] );
		Toffoli( q[0], anc[0], anc[2] );
		Toffoli( anc[7], anc[0], q[2] );
		CNOT( anc[5], anc[6] );
		CNOT( anc[3], q[2] );
		Toffoli( anc[1], anc[4], anc[5] );
	}
	Restore {
		CNOT( anc[4], res[0] );
		CNOT( q[2], res[1] );
	}
	Unrecompute {
		Toffoli( anc[1], anc[4], anc[5] );
		CNOT( anc[3], q[2] );
		CNOT( anc[5], anc[6] );
		Toffoli( anc[7], anc[0], q[2] );
		Toffoli( q[0], anc[0], anc[2] );
		CNOT( anc[6], q[1] );
		Toffoli( anc[1], anc[6], q[2] );
		Toffoli( anc[0], anc[3], anc[6] );
	} Refree(anc, 8) {}
}
// Function 19 with degree 0
// nq: 4, na: 2, ng: 1
void func19(qbit **q, int n) {
printf("func19\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[2];
	nb[0] = q[3];
	nb[1] = q[2];
	res[0] = q[3];
	res[1] = q[2];
	// Leaf function
	Compute (0, 2, 4, 3, 0, 3, 0) {
		acquire(2, anc, 2, nb);
		Toffoli( q[3], anc[1], q[2] );
	}
	Store {
		CNOT( q[2], res[0] );
		CNOT( anc[1], res[1] );
	}
	Uncompute(res, 0, anc, 2, 4, 3){
		Toffoli( q[3], anc[1], q[2] );
	} Free(anc, 2) {}
}
// Function 19 with degree 0
// nq: 4, na: 2, ng: 1
void func19R(qbit **q, int n) {
printf("func19R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[2];
	nb[0] = q[3];
	nb[1] = q[2];
	res[0] = q[3];
	res[1] = q[2];
	// Leaf function
	_computeModule(0, 2, 4, 3, 0, 3, 0);
	acquire(2, anc, 2, nb);
	Recompute (res, 0, anc, 2, 4, 3){
		Toffoli( q[3], anc[1], q[2] );
	}
	Restore {
		CNOT( q[2], res[0] );
		CNOT( anc[1], res[1] );
	}
	Unrecompute {
		Toffoli( q[3], anc[1], q[2] );
	} Refree(anc, 2) {}
}
// Function 18 with degree 0
// nq: 4, na: 7, ng: 3
void func18(qbit **q, int n) {
printf("func18\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[3]; // interacting bits
	qbit *res[4];
	nb[0] = q[2];
	nb[1] = q[0];
	nb[2] = q[3];
	res[0] = q[1];
	res[1] = q[3];
	res[2] = q[0];
	res[3] = q[2];
	// Leaf function
	Compute (0, 7, 10, 7, 0, 3, 0) {
		acquire(7, anc, 3, nb);
		CNOT( anc[6], anc[2] );
		Toffoli( q[2], anc[0], anc[3] );
		Toffoli( q[0], q[3], anc[2] );
	}
	Store {
		CNOT( anc[6], res[0] );
		CNOT( anc[4], res[1] );
		CNOT( q[1], res[2] );
		CNOT( anc[3], res[3] );
	}
	Uncompute(res, 0, anc, 7, 10, 7){
		Toffoli( q[0], q[3], anc[2] );
		Toffoli( q[2], anc[0], anc[3] );
		CNOT( anc[6], anc[2] );
	} Free(anc, 7) {}
}
// Function 18 with degree 0
// nq: 4, na: 7, ng: 3
void func18R(qbit **q, int n) {
printf("func18R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[3]; // interacting bits
	qbit *res[4];
	nb[0] = q[2];
	nb[1] = q[0];
	nb[2] = q[3];
	res[0] = q[1];
	res[1] = q[3];
	res[2] = q[0];
	res[3] = q[2];
	// Leaf function
	_computeModule(0, 7, 10, 7, 0, 3, 0);
	acquire(7, anc, 3, nb);
	Recompute (res, 0, anc, 7, 10, 7){
		Toffoli( q[0], q[3], anc[2] );
		Toffoli( q[2], anc[0], anc[3] );
		CNOT( anc[6], anc[2] );
	}
	Restore {
		CNOT( anc[6], res[0] );
		CNOT( anc[4], res[1] );
		CNOT( q[1], res[2] );
		CNOT( anc[3], res[3] );
	}
	Unrecompute {
		CNOT( anc[6], anc[2] );
		Toffoli( q[2], anc[0], anc[3] );
		Toffoli( q[0], q[3], anc[2] );
	} Refree(anc, 7) {}
}
// Function 17 with degree 0
// nq: 4, na: 1, ng: 1
void func17(qbit **q, int n) {
printf("func17\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[1]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	res[0] = q[0];
	// Leaf function
	Compute (0, 1, 3, 2, 0, 3, 0) {
		acquire(1, anc, 1, nb);
		CNOT( anc[0], q[0] );
	}
	Store {
		CNOT( anc[0], res[0] );
	}
	Uncompute(res, 0, anc, 1, 3, 2){
		CNOT( anc[0], q[0] );
	} Free(anc, 1) {}
}
// Function 17 with degree 0
// nq: 4, na: 1, ng: 1
void func17R(qbit **q, int n) {
printf("func17R\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[1]; // interacting bits
	qbit *res[1];
	nb[0] = q[0];
	res[0] = q[0];
	// Leaf function
	_computeModule(0, 1, 3, 2, 0, 3, 0);
	acquire(1, anc, 1, nb);
	Recompute (res, 0, anc, 1, 3, 2){
		CNOT( anc[0], q[0] );
	}
	Restore {
		CNOT( anc[0], res[0] );
	}
	Unrecompute {
		CNOT( anc[0], q[0] );
	} Refree(anc, 1) {}
}
// Function 16 with degree 0
// nq: 11, na: 8, ng: 2
void func16(qbit **q, int n) {
printf("func16\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[4]; // interacting bits
	qbit *res[4];
	nb[0] = q[6];
	nb[1] = q[1];
	nb[2] = q[5];
	nb[3] = q[1];
	res[0] = q[3];
	res[1] = q[1];
	res[2] = q[7];
	res[3] = q[0];
	// Leaf function
	Compute (0, 8, 8, 6, 0, 1, 0) {
		acquire(8, anc, 4, nb);
		CNOT( q[6], q[1] );
		Toffoli( q[5], anc[5], q[1] );
	}
	Store {
		CNOT( anc[2], res[0] );
		CNOT( anc[1], res[1] );
		CNOT( anc[7], res[2] );
		CNOT( q[10], res[3] );
	}
	Uncompute(res, 0, anc, 8, 8, 6){
		Toffoli( q[5], anc[5], q[1] );
		CNOT( q[6], q[1] );
	} Free(anc, 8) {}
}
// Function 16 with degree 0
// nq: 11, na: 8, ng: 2
void func16R(qbit **q, int n) {
printf("func16R\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[4]; // interacting bits
	qbit *res[4];
	nb[0] = q[6];
	nb[1] = q[1];
	nb[2] = q[5];
	nb[3] = q[1];
	res[0] = q[3];
	res[1] = q[1];
	res[2] = q[7];
	res[3] = q[0];
	// Leaf function
	_computeModule(0, 8, 8, 6, 0, 1, 0);
	acquire(8, anc, 4, nb);
	Recompute (res, 0, anc, 8, 8, 6){
		Toffoli( q[5], anc[5], q[1] );
		CNOT( q[6], q[1] );
	}
	Restore {
		CNOT( anc[2], res[0] );
		CNOT( anc[1], res[1] );
		CNOT( anc[7], res[2] );
		CNOT( q[10], res[3] );
	}
	Unrecompute {
		CNOT( q[6], q[1] );
		Toffoli( q[5], anc[5], q[1] );
	} Refree(anc, 8) {}
}
// Function 15 with degree 2
// nq: 31, na: 8, ng: 4
void func15(qbit **q, int n) {
printf("func15\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[7]; // interacting bits
	qbit *res[24];
	qbit *nq0[19];
	qbit *nq1[19];
	nb[0] = q[25];
	nb[1] = q[8];
	nb[2] = q[2];
	nb[3] = q[21];
	nb[4] = q[19];
	nb[5] = q[14];
	nb[6] = q[7];
	res[0] = q[4];
	res[1] = q[28];
	res[2] = q[30];
	res[3] = q[9];
	res[4] = q[3];
	res[5] = q[24];
	res[6] = q[19];
	res[7] = q[14];
	res[8] = q[11];
	res[9] = q[6];
	res[10] = q[7];
	res[11] = q[15];
	res[12] = q[18];
	res[13] = q[22];
	res[14] = q[20];
	res[15] = q[5];
	res[16] = q[16];
	res[17] = q[26];
	res[18] = q[17];
	res[19] = q[0];
	res[20] = q[10];
	res[21] = q[25];
	res[22] = q[13];
	res[23] = q[8];
	// Non-leaf function
	Compute (0, 8, 32, 28, 2, 1, 0){
		acquire(8, anc, 7, nb);
	nq0[0] = q[27];
	nq0[1] = q[5];
	nq0[2] = q[22];
	nq0[3] = q[19];
	nq0[4] = q[7];
	nq0[5] = anc[4];
	nq0[6] = q[13];
	nq0[7] = q[1];
	nq0[8] = q[9];
	nq0[9] = q[12];
	nq0[10] = q[15];
	nq0[11] = q[10];
	nq0[12] = q[20];
	nq0[13] = anc[5];
	nq0[14] = q[4];
	nq0[15] = q[18];
	nq0[16] = q[11];
	nq0[17] = q[26];
	nq0[18] = anc[1];
	nq1[0] = q[3];
	nq1[1] = q[24];
	nq1[2] = anc[3];
	nq1[3] = q[16];
	nq1[4] = q[28];
	nq1[5] = q[6];
	nq1[6] = q[25];
	nq1[7] = q[2];
	nq1[8] = anc[6];
	nq1[9] = q[21];
	nq1[10] = q[30];
	nq1[11] = anc[0];
	nq1[12] = q[17];
	nq1[13] = q[8];
	nq1[14] = q[29];
	nq1[15] = q[0];
	nq1[16] = anc[7];
	nq1[17] = q[14];
	nq1[18] = anc[2];
		CNOT( q[21], q[19] );
		CNOT( q[2], anc[7] );
		func27(nq0, 19);
		func28(nq1, 19);
		CNOT( q[25], q[8] );
		CNOT( q[14], q[7] );
	}
	Store {
		CNOT( q[25], res[0] );
		CNOT( q[1], res[1] );
		CNOT( q[15], res[2] );
		CNOT( q[19], res[3] );
		CNOT( q[10], res[4] );
		CNOT( q[30], res[5] );
		CNOT( q[18], res[6] );
		CNOT( q[21], res[7] );
		CNOT( q[3], res[8] );
		CNOT( q[5], res[9] );
		CNOT( anc[2], res[10] );
		CNOT( q[26], res[11] );
		CNOT( q[20], res[12] );
		CNOT( anc[0], res[13] );
		CNOT( anc[7], res[14] );
		CNOT( anc[3], res[15] );
		CNOT( anc[1], res[16] );
		CNOT( q[22], res[17] );
		CNOT( anc[4], res[18] );
		CNOT( q[7], res[19] );
		CNOT( q[6], res[20] );
		CNOT( q[17], res[21] );
		CNOT( anc[6], res[22] );
		CNOT( q[9], res[23] );
	}
	Uncompute(res, 0, anc, 8, 32, 28){
		CNOT( q[14], q[7] );
		CNOT( q[25], q[8] );
		func28R(nq1, 19);
		func27R(nq0, 19);
		CNOT( q[2], anc[7] );
		CNOT( q[21], q[19] );
	} Free(anc, 8) {}
}
// Function 15 with degree 2
// nq: 31, na: 8, ng: 4
void func15R(qbit **q, int n) {
printf("func15R\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[7]; // interacting bits
	qbit *res[24];
	qbit *nq0[19];
	qbit *nq1[19];
	nb[0] = q[25];
	nb[1] = q[8];
	nb[2] = q[2];
	nb[3] = q[21];
	nb[4] = q[19];
	nb[5] = q[14];
	nb[6] = q[7];
	res[0] = q[4];
	res[1] = q[28];
	res[2] = q[30];
	res[3] = q[9];
	res[4] = q[3];
	res[5] = q[24];
	res[6] = q[19];
	res[7] = q[14];
	res[8] = q[11];
	res[9] = q[6];
	res[10] = q[7];
	res[11] = q[15];
	res[12] = q[18];
	res[13] = q[22];
	res[14] = q[20];
	res[15] = q[5];
	res[16] = q[16];
	res[17] = q[26];
	res[18] = q[17];
	res[19] = q[0];
	res[20] = q[10];
	res[21] = q[25];
	res[22] = q[13];
	res[23] = q[8];
	// Non-leaf function
	_computeModule(0, 8, 32, 28, 2, 1, 0);
	acquire(8, anc, 7, nb);
	nq0[0] = q[27];
	nq0[1] = q[5];
	nq0[2] = q[22];
	nq0[3] = q[19];
	nq0[4] = q[7];
	nq0[5] = anc[4];
	nq0[6] = q[13];
	nq0[7] = q[1];
	nq0[8] = q[9];
	nq0[9] = q[12];
	nq0[10] = q[15];
	nq0[11] = q[10];
	nq0[12] = q[20];
	nq0[13] = anc[5];
	nq0[14] = q[4];
	nq0[15] = q[18];
	nq0[16] = q[11];
	nq0[17] = q[26];
	nq0[18] = anc[1];
	nq1[0] = q[3];
	nq1[1] = q[24];
	nq1[2] = anc[3];
	nq1[3] = q[16];
	nq1[4] = q[28];
	nq1[5] = q[6];
	nq1[6] = q[25];
	nq1[7] = q[2];
	nq1[8] = anc[6];
	nq1[9] = q[21];
	nq1[10] = q[30];
	nq1[11] = anc[0];
	nq1[12] = q[17];
	nq1[13] = q[8];
	nq1[14] = q[29];
	nq1[15] = q[0];
	nq1[16] = anc[7];
	nq1[17] = q[14];
	nq1[18] = anc[2];
	Recompute(res, 0, anc, 8, 32, 28){
		CNOT( q[21], q[19] );
		CNOT( q[2], anc[7] );
		func27(nq0, 19);
		func28(nq1, 19);
		CNOT( q[25], q[8] );
		CNOT( q[14], q[7] );
	}
	Restore {
		CNOT( q[25], res[0] );
		CNOT( q[1], res[1] );
		CNOT( q[15], res[2] );
		CNOT( q[19], res[3] );
		CNOT( q[10], res[4] );
		CNOT( q[30], res[5] );
		CNOT( q[18], res[6] );
		CNOT( q[21], res[7] );
		CNOT( q[3], res[8] );
		CNOT( q[5], res[9] );
		CNOT( anc[2], res[10] );
		CNOT( q[26], res[11] );
		CNOT( q[20], res[12] );
		CNOT( anc[0], res[13] );
		CNOT( anc[7], res[14] );
		CNOT( anc[3], res[15] );
		CNOT( anc[1], res[16] );
		CNOT( q[22], res[17] );
		CNOT( anc[4], res[18] );
		CNOT( q[7], res[19] );
		CNOT( q[6], res[20] );
		CNOT( q[17], res[21] );
		CNOT( anc[6], res[22] );
		CNOT( q[9], res[23] );
	}
	Unrecompute {
		CNOT( q[14], q[7] );
		CNOT( q[25], q[8] );
		func28R(nq1, 19);
		func27R(nq0, 19);
		CNOT( q[2], anc[7] );
		CNOT( q[21], q[19] );
	} Refree(anc, 8) {}
}
// Function 14 with degree 2
// nq: 17, na: 1, ng: 1
void func14(qbit **q, int n) {
printf("func14\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[3];
	qbit *nq0[9];
	qbit *nq1[9];
	nb[0] = q[4];
	nb[1] = q[13];
	res[0] = q[7];
	res[1] = q[6];
	res[2] = q[15];
	// Non-leaf function
	Compute (0, 1, 5, 4, 2, 1, 0){
		acquire(1, anc, 2, nb);
	nq0[0] = q[6];
	nq0[1] = q[14];
	nq0[2] = q[4];
	nq0[3] = q[16];
	nq0[4] = anc[0];
	nq0[5] = q[12];
	nq0[6] = q[2];
	nq0[7] = q[0];
	nq0[8] = q[9];
	nq1[0] = q[3];
	nq1[1] = q[15];
	nq1[2] = q[1];
	nq1[3] = q[11];
	nq1[4] = q[13];
	nq1[5] = q[8];
	nq1[6] = q[5];
	nq1[7] = q[7];
	nq1[8] = q[10];
		func25(nq0, 9);
		CNOT( q[4], q[13] );
		func26(nq1, 9);
	}
	Store {
		CNOT( q[0], res[0] );
		CNOT( q[13], res[1] );
		CNOT( q[7], res[2] );
	}
	Uncompute(res, 0, anc, 1, 5, 4){
		func26R(nq1, 9);
		CNOT( q[4], q[13] );
		func25R(nq0, 9);
	} Free(anc, 1) {}
}
// Function 14 with degree 2
// nq: 17, na: 1, ng: 1
void func14R(qbit **q, int n) {
printf("func14R\n");
fflush(stderr);
	qbit *anc[1]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[3];
	qbit *nq0[9];
	qbit *nq1[9];
	nb[0] = q[4];
	nb[1] = q[13];
	res[0] = q[7];
	res[1] = q[6];
	res[2] = q[15];
	// Non-leaf function
	_computeModule(0, 1, 5, 4, 2, 1, 0);
	acquire(1, anc, 2, nb);
	nq0[0] = q[6];
	nq0[1] = q[14];
	nq0[2] = q[4];
	nq0[3] = q[16];
	nq0[4] = anc[0];
	nq0[5] = q[12];
	nq0[6] = q[2];
	nq0[7] = q[0];
	nq0[8] = q[9];
	nq1[0] = q[3];
	nq1[1] = q[15];
	nq1[2] = q[1];
	nq1[3] = q[11];
	nq1[4] = q[13];
	nq1[5] = q[8];
	nq1[6] = q[5];
	nq1[7] = q[7];
	nq1[8] = q[10];
	Recompute(res, 0, anc, 1, 5, 4){
		func25(nq0, 9);
		CNOT( q[4], q[13] );
		func26(nq1, 9);
	}
	Restore {
		CNOT( q[0], res[0] );
		CNOT( q[13], res[1] );
		CNOT( q[7], res[2] );
	}
	Unrecompute {
		func26R(nq1, 9);
		CNOT( q[4], q[13] );
		func25R(nq0, 9);
	} Refree(anc, 1) {}
}
// Function 13 with degree 2
// nq: 7, na: 8, ng: 5
void func13(qbit **q, int n) {
printf("func13\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[7];
	qbit *nq0[7];
	qbit *nq1[7];
	nb[0] = q[1];
	nb[1] = q[2];
	nb[2] = q[1];
	nb[3] = q[2];
	nb[4] = q[1];
	nb[5] = q[6];
	nb[6] = q[6];
	nb[7] = q[2];
	nb[8] = q[2];
	res[0] = q[3];
	res[1] = q[0];
	res[2] = q[6];
	res[3] = q[1];
	res[4] = q[4];
	res[5] = q[5];
	res[6] = q[2];
	// Non-leaf function
	Compute (0, 8, 17, 12, 2, 3, 0){
		acquire(8, anc, 9, nb);
	nq0[0] = anc[4];
	nq0[1] = anc[3];
	nq0[2] = q[5];
	nq0[3] = anc[2];
	nq0[4] = q[2];
	nq0[5] = anc[0];
	nq0[6] = q[1];
	nq1[0] = q[6];
	nq1[1] = q[0];
	nq1[2] = anc[5];
	nq1[3] = anc[1];
	nq1[4] = anc[6];
	nq1[5] = anc[7];
	nq1[6] = q[3];
		Toffoli( q[1], q[2], anc[7] );
		func24(nq1, 7);
		func23(nq0, 7);
		Toffoli( q[6], q[2], anc[2] );
		Toffoli( anc[5], anc[6], q[2] );
		CNOT( q[1], q[2] );
		CNOT( q[1], q[6] );
	}
	Store {
		CNOT( anc[6], res[0] );
		CNOT( anc[2], res[1] );
		CNOT( q[1], res[2] );
		CNOT( q[3], res[3] );
		CNOT( q[5], res[4] );
		CNOT( anc[3], res[5] );
		CNOT( q[0], res[6] );
	}
	Uncompute(res, 0, anc, 8, 17, 12){
		CNOT( q[1], q[6] );
		CNOT( q[1], q[2] );
		Toffoli( anc[5], anc[6], q[2] );
		Toffoli( q[6], q[2], anc[2] );
		func23R(nq0, 7);
		func24R(nq1, 7);
		Toffoli( q[1], q[2], anc[7] );
	} Free(anc, 8) {}
}
// Function 13 with degree 2
// nq: 7, na: 8, ng: 5
void func13R(qbit **q, int n) {
printf("func13R\n");
fflush(stderr);
	qbit *anc[8]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[7];
	qbit *nq0[7];
	qbit *nq1[7];
	nb[0] = q[1];
	nb[1] = q[2];
	nb[2] = q[1];
	nb[3] = q[2];
	nb[4] = q[1];
	nb[5] = q[6];
	nb[6] = q[6];
	nb[7] = q[2];
	nb[8] = q[2];
	res[0] = q[3];
	res[1] = q[0];
	res[2] = q[6];
	res[3] = q[1];
	res[4] = q[4];
	res[5] = q[5];
	res[6] = q[2];
	// Non-leaf function
	_computeModule(0, 8, 17, 12, 2, 3, 0);
	acquire(8, anc, 9, nb);
	nq0[0] = anc[4];
	nq0[1] = anc[3];
	nq0[2] = q[5];
	nq0[3] = anc[2];
	nq0[4] = q[2];
	nq0[5] = anc[0];
	nq0[6] = q[1];
	nq1[0] = q[6];
	nq1[1] = q[0];
	nq1[2] = anc[5];
	nq1[3] = anc[1];
	nq1[4] = anc[6];
	nq1[5] = anc[7];
	nq1[6] = q[3];
	Recompute(res, 0, anc, 8, 17, 12){
		Toffoli( q[1], q[2], anc[7] );
		func24(nq1, 7);
		func23(nq0, 7);
		Toffoli( q[6], q[2], anc[2] );
		Toffoli( anc[5], anc[6], q[2] );
		CNOT( q[1], q[2] );
		CNOT( q[1], q[6] );
	}
	Restore {
		CNOT( anc[6], res[0] );
		CNOT( anc[2], res[1] );
		CNOT( q[1], res[2] );
		CNOT( q[3], res[3] );
		CNOT( q[5], res[4] );
		CNOT( anc[3], res[5] );
		CNOT( q[0], res[6] );
	}
	Unrecompute {
		CNOT( q[1], q[6] );
		CNOT( q[1], q[2] );
		Toffoli( anc[5], anc[6], q[2] );
		Toffoli( q[6], q[2], anc[2] );
		func23R(nq0, 7);
		func24R(nq1, 7);
		Toffoli( q[1], q[2], anc[7] );
	} Refree(anc, 8) {}
}
// Function 12 with degree 3
// nq: 7, na: 2, ng: 7
void func12(qbit **q, int n) {
printf("func12\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[11]; // interacting bits
	qbit *res[2];
	qbit *nq0[3];
	qbit *nq1[3];
	qbit *nq2[3];
	nb[0] = q[5];
	nb[1] = q[3];
	nb[2] = q[0];
	nb[3] = q[5];
	nb[4] = q[1];
	nb[5] = q[2];
	nb[6] = q[4];
	nb[7] = q[5];
	nb[8] = q[2];
	nb[9] = q[3];
	nb[10] = q[1];
	res[0] = q[0];
	res[1] = q[2];
	// Non-leaf function
	Compute (0, 2, 16, 9, 3, 3, 0){
		acquire(2, anc, 11, nb);
	nq0[0] = anc[0];
	nq0[1] = q[6];
	nq0[2] = q[5];
	nq1[0] = q[0];
	nq1[1] = anc[1];
	nq1[2] = q[2];
	nq2[0] = q[3];
	nq2[1] = q[4];
	nq2[2] = q[1];
		CNOT( q[5], q[2] );
		func20(nq0, 3);
		CNOT( anc[1], q[4] );
		func21(nq1, 3);
		func22(nq2, 3);
		CNOT( q[1], q[2] );
		CNOT( q[3], q[1] );
		CNOT( q[3], q[0] );
		Toffoli( anc[1], q[5], anc[0] );
		CNOT( q[5], anc[0] );
	}
	Store {
		CNOT( anc[1], res[0] );
		CNOT( q[1], res[1] );
	}
	Uncompute(res, 0, anc, 2, 16, 9){
		CNOT( q[5], anc[0] );
		Toffoli( anc[1], q[5], anc[0] );
		CNOT( q[3], q[0] );
		CNOT( q[3], q[1] );
		CNOT( q[1], q[2] );
		func22R(nq2, 3);
		func21R(nq1, 3);
		CNOT( anc[1], q[4] );
		func20R(nq0, 3);
		CNOT( q[5], q[2] );
	} Free(anc, 2) {}
}
// Function 12 with degree 3
// nq: 7, na: 2, ng: 7
void func12R(qbit **q, int n) {
printf("func12R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[11]; // interacting bits
	qbit *res[2];
	qbit *nq0[3];
	qbit *nq1[3];
	qbit *nq2[3];
	nb[0] = q[5];
	nb[1] = q[3];
	nb[2] = q[0];
	nb[3] = q[5];
	nb[4] = q[1];
	nb[5] = q[2];
	nb[6] = q[4];
	nb[7] = q[5];
	nb[8] = q[2];
	nb[9] = q[3];
	nb[10] = q[1];
	res[0] = q[0];
	res[1] = q[2];
	// Non-leaf function
	_computeModule(0, 2, 16, 9, 3, 3, 0);
	acquire(2, anc, 11, nb);
	nq0[0] = anc[0];
	nq0[1] = q[6];
	nq0[2] = q[5];
	nq1[0] = q[0];
	nq1[1] = anc[1];
	nq1[2] = q[2];
	nq2[0] = q[3];
	nq2[1] = q[4];
	nq2[2] = q[1];
	Recompute(res, 0, anc, 2, 16, 9){
		CNOT( q[5], q[2] );
		func20(nq0, 3);
		CNOT( anc[1], q[4] );
		func21(nq1, 3);
		func22(nq2, 3);
		CNOT( q[1], q[2] );
		CNOT( q[3], q[1] );
		CNOT( q[3], q[0] );
		Toffoli( anc[1], q[5], anc[0] );
		CNOT( q[5], anc[0] );
	}
	Restore {
		CNOT( anc[1], res[0] );
		CNOT( q[1], res[1] );
	}
	Unrecompute {
		CNOT( q[5], anc[0] );
		Toffoli( anc[1], q[5], anc[0] );
		CNOT( q[3], q[0] );
		CNOT( q[3], q[1] );
		CNOT( q[1], q[2] );
		func22R(nq2, 3);
		func21R(nq1, 3);
		CNOT( anc[1], q[4] );
		func20R(nq0, 3);
		CNOT( q[5], q[2] );
	} Refree(anc, 2) {}
}
// Function 11 with degree 0
// nq: 7, na: 5, ng: 1
void func11(qbit **q, int n) {
printf("func11\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[7];
	nb[0] = q[0];
	nb[1] = q[6];
	res[0] = q[2];
	res[1] = q[3];
	res[2] = q[6];
	res[3] = q[1];
	res[4] = q[0];
	res[5] = q[4];
	res[6] = q[5];
	// Leaf function
	Compute (0, 5, 9, 8, 0, 3, 0) {
		acquire(5, anc, 2, nb);
		Toffoli( anc[3], q[0], q[6] );
	}
	Store {
		CNOT( anc[3], res[0] );
		CNOT( q[4], res[1] );
		CNOT( anc[2], res[2] );
		CNOT( q[2], res[3] );
		CNOT( anc[1], res[4] );
		CNOT( q[3], res[5] );
		CNOT( q[1], res[6] );
	}
	Uncompute(res, 0, anc, 5, 9, 8){
		Toffoli( anc[3], q[0], q[6] );
	} Free(anc, 5) {}
}
// Function 11 with degree 0
// nq: 7, na: 5, ng: 1
void func11R(qbit **q, int n) {
printf("func11R\n");
fflush(stderr);
	qbit *anc[5]; // ancilla
	qbit *nb[2]; // interacting bits
	qbit *res[7];
	nb[0] = q[0];
	nb[1] = q[6];
	res[0] = q[2];
	res[1] = q[3];
	res[2] = q[6];
	res[3] = q[1];
	res[4] = q[0];
	res[5] = q[4];
	res[6] = q[5];
	// Leaf function
	_computeModule(0, 5, 9, 8, 0, 3, 0);
	acquire(5, anc, 2, nb);
	Recompute (res, 0, anc, 5, 9, 8){
		Toffoli( anc[3], q[0], q[6] );
	}
	Restore {
		CNOT( anc[3], res[0] );
		CNOT( q[4], res[1] );
		CNOT( anc[2], res[2] );
		CNOT( q[2], res[3] );
		CNOT( anc[1], res[4] );
		CNOT( q[3], res[5] );
		CNOT( q[1], res[6] );
	}
	Unrecompute {
		Toffoli( anc[3], q[0], q[6] );
	} Refree(anc, 5) {}
}
// Function 10 with degree 3
// nq: 9, na: 4, ng: 3
void func10(qbit **q, int n) {
printf("func10\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[3]; // interacting bits
	qbit *res[9];
	qbit *nq0[4];
	qbit *nq1[4];
	qbit *nq2[4];
	nb[0] = q[0];
	nb[1] = q[5];
	nb[2] = q[4];
	res[0] = q[5];
	res[1] = q[2];
	res[2] = q[0];
	res[3] = q[8];
	res[4] = q[3];
	res[5] = q[4];
	res[6] = q[7];
	res[7] = q[6];
	res[8] = q[1];
	// Non-leaf function
	Compute (0, 4, 15, 12, 3, 2, 0){
		acquire(4, anc, 3, nb);
	nq0[0] = q[6];
	nq0[1] = q[4];
	nq0[2] = q[7];
	nq0[3] = q[1];
	nq1[0] = anc[0];
	nq1[1] = anc[3];
	nq1[2] = q[0];
	nq1[3] = anc[1];
	nq2[0] = q[5];
	nq2[1] = q[8];
	nq2[2] = q[3];
	nq2[3] = q[2];
		func17(nq0, 4);
		CNOT( anc[2], q[0] );
		Toffoli( anc[2], q[4], anc[0] );
		func18(nq1, 4);
		CNOT( q[5], anc[2] );
		func19(nq2, 4);
	}
	Store {
		CNOT( anc[3], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( q[7], res[2] );
		CNOT( q[4], res[3] );
		CNOT( anc[1], res[4] );
		CNOT( q[8], res[5] );
		CNOT( q[0], res[6] );
		CNOT( anc[0], res[7] );
		CNOT( anc[2], res[8] );
	}
	Uncompute(res, 0, anc, 4, 15, 12){
		func19R(nq2, 4);
		CNOT( q[5], anc[2] );
		func18R(nq1, 4);
		Toffoli( anc[2], q[4], anc[0] );
		CNOT( anc[2], q[0] );
		func17R(nq0, 4);
	} Free(anc, 4) {}
}
// Function 10 with degree 3
// nq: 9, na: 4, ng: 3
void func10R(qbit **q, int n) {
printf("func10R\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[3]; // interacting bits
	qbit *res[9];
	qbit *nq0[4];
	qbit *nq1[4];
	qbit *nq2[4];
	nb[0] = q[0];
	nb[1] = q[5];
	nb[2] = q[4];
	res[0] = q[5];
	res[1] = q[2];
	res[2] = q[0];
	res[3] = q[8];
	res[4] = q[3];
	res[5] = q[4];
	res[6] = q[7];
	res[7] = q[6];
	res[8] = q[1];
	// Non-leaf function
	_computeModule(0, 4, 15, 12, 3, 2, 0);
	acquire(4, anc, 3, nb);
	nq0[0] = q[6];
	nq0[1] = q[4];
	nq0[2] = q[7];
	nq0[3] = q[1];
	nq1[0] = anc[0];
	nq1[1] = anc[3];
	nq1[2] = q[0];
	nq1[3] = anc[1];
	nq2[0] = q[5];
	nq2[1] = q[8];
	nq2[2] = q[3];
	nq2[3] = q[2];
	Recompute(res, 0, anc, 4, 15, 12){
		func17(nq0, 4);
		CNOT( anc[2], q[0] );
		Toffoli( anc[2], q[4], anc[0] );
		func18(nq1, 4);
		CNOT( q[5], anc[2] );
		func19(nq2, 4);
	}
	Restore {
		CNOT( anc[3], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( q[7], res[2] );
		CNOT( q[4], res[3] );
		CNOT( anc[1], res[4] );
		CNOT( q[8], res[5] );
		CNOT( q[0], res[6] );
		CNOT( anc[0], res[7] );
		CNOT( anc[2], res[8] );
	}
	Unrecompute {
		func19R(nq2, 4);
		CNOT( q[5], anc[2] );
		func18R(nq1, 4);
		Toffoli( anc[2], q[4], anc[0] );
		CNOT( anc[2], q[0] );
		func17R(nq0, 4);
	} Refree(anc, 4) {}
}
// Function 9 with degree 1
// nq: 9, na: 2, ng: 4
void func9(qbit **q, int n) {
printf("func9\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[2];
	qbit *nq0[11];
	nb[0] = q[3];
	nb[1] = q[6];
	nb[2] = q[4];
	nb[3] = q[5];
	nb[4] = q[6];
	nb[5] = q[3];
	nb[6] = q[1];
	nb[7] = q[2];
	nb[8] = q[8];
	res[0] = q[7];
	res[1] = q[8];
	// Non-leaf function
	Compute (0, 2, 10, 6, 1, 2, 0){
		acquire(2, anc, 9, nb);
	nq0[0] = q[6];
	nq0[1] = q[7];
	nq0[2] = anc[0];
	nq0[3] = anc[1];
	nq0[4] = q[4];
	nq0[5] = q[2];
	nq0[6] = q[5];
	nq0[7] = q[8];
	nq0[8] = q[1];
	nq0[9] = q[0];
	nq0[10] = q[3];
		CNOT( q[5], q[6] );
		Toffoli( q[3], q[6], q[4] );
		Toffoli( q[1], q[2], q[8] );
		func16(nq0, 11);
		CNOT( anc[0], q[3] );
	}
	Store {
		CNOT( q[5], res[0] );
		CNOT( anc[1], res[1] );
	}
	Uncompute(res, 0, anc, 2, 10, 6){
		CNOT( anc[0], q[3] );
		func16R(nq0, 11);
		Toffoli( q[1], q[2], q[8] );
		Toffoli( q[3], q[6], q[4] );
		CNOT( q[5], q[6] );
	} Free(anc, 2) {}
}
// Function 9 with degree 1
// nq: 9, na: 2, ng: 4
void func9R(qbit **q, int n) {
printf("func9R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[9]; // interacting bits
	qbit *res[2];
	qbit *nq0[11];
	nb[0] = q[3];
	nb[1] = q[6];
	nb[2] = q[4];
	nb[3] = q[5];
	nb[4] = q[6];
	nb[5] = q[3];
	nb[6] = q[1];
	nb[7] = q[2];
	nb[8] = q[8];
	res[0] = q[7];
	res[1] = q[8];
	// Non-leaf function
	_computeModule(0, 2, 10, 6, 1, 2, 0);
	acquire(2, anc, 9, nb);
	nq0[0] = q[6];
	nq0[1] = q[7];
	nq0[2] = anc[0];
	nq0[3] = anc[1];
	nq0[4] = q[4];
	nq0[5] = q[2];
	nq0[6] = q[5];
	nq0[7] = q[8];
	nq0[8] = q[1];
	nq0[9] = q[0];
	nq0[10] = q[3];
	Recompute(res, 0, anc, 2, 10, 6){
		CNOT( q[5], q[6] );
		Toffoli( q[3], q[6], q[4] );
		Toffoli( q[1], q[2], q[8] );
		func16(nq0, 11);
		CNOT( anc[0], q[3] );
	}
	Restore {
		CNOT( q[5], res[0] );
		CNOT( anc[1], res[1] );
	}
	Unrecompute {
		CNOT( anc[0], q[3] );
		func16R(nq0, 11);
		Toffoli( q[1], q[2], q[8] );
		Toffoli( q[3], q[6], q[4] );
		CNOT( q[5], q[6] );
	} Refree(anc, 2) {}
}
// Function 8 with degree 1
// nq: 24, na: 7, ng: 2
void func8(qbit **q, int n) {
printf("func8\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[5]; // interacting bits
	qbit *res[20];
	qbit *nq0[31];
	nb[0] = q[0];
	nb[1] = q[18];
	nb[2] = q[20];
	nb[3] = q[17];
	nb[4] = q[1];
	res[0] = q[11];
	res[1] = q[15];
	res[2] = q[18];
	res[3] = q[20];
	res[4] = q[14];
	res[5] = q[5];
	res[6] = q[21];
	res[7] = q[0];
	res[8] = q[7];
	res[9] = q[19];
	res[10] = q[16];
	res[11] = q[2];
	res[12] = q[4];
	res[13] = q[10];
	res[14] = q[8];
	res[15] = q[13];
	res[16] = q[17];
	res[17] = q[9];
	res[18] = q[3];
	res[19] = q[12];
	// Non-leaf function
	Compute (0, 7, 24, 22, 1, 2, 0){
		acquire(7, anc, 5, nb);
	nq0[0] = q[17];
	nq0[1] = q[14];
	nq0[2] = anc[2];
	nq0[3] = q[13];
	nq0[4] = q[2];
	nq0[5] = q[11];
	nq0[6] = q[20];
	nq0[7] = anc[0];
	nq0[8] = anc[1];
	nq0[9] = q[12];
	nq0[10] = q[10];
	nq0[11] = q[23];
	nq0[12] = q[16];
	nq0[13] = anc[4];
	nq0[14] = q[9];
	nq0[15] = q[21];
	nq0[16] = q[1];
	nq0[17] = q[15];
	nq0[18] = q[6];
	nq0[19] = q[8];
	nq0[20] = anc[3];
	nq0[21] = q[4];
	nq0[22] = q[0];
	nq0[23] = q[18];
	nq0[24] = anc[5];
	nq0[25] = q[19];
	nq0[26] = q[22];
	nq0[27] = q[7];
	nq0[28] = q[3];
	nq0[29] = anc[6];
	nq0[30] = q[5];
		CNOT( q[0], q[18] );
		Toffoli( q[20], q[17], q[1] );
		func15(nq0, 31);
	}
	Store {
		CNOT( q[23], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( q[22], res[2] );
		CNOT( q[14], res[3] );
		CNOT( q[13], res[4] );
		CNOT( anc[3], res[5] );
		CNOT( q[11], res[6] );
		CNOT( q[8], res[7] );
		CNOT( q[2], res[8] );
		CNOT( q[18], res[9] );
		CNOT( q[6], res[10] );
		CNOT( q[20], res[11] );
		CNOT( q[0], res[12] );
		CNOT( q[1], res[13] );
		CNOT( anc[6], res[14] );
		CNOT( q[16], res[15] );
		CNOT( q[10], res[16] );
		CNOT( anc[5], res[17] );
		CNOT( q[17], res[18] );
		CNOT( q[5], res[19] );
	}
	Uncompute(res, 0, anc, 7, 24, 22){
		func15R(nq0, 31);
		Toffoli( q[20], q[17], q[1] );
		CNOT( q[0], q[18] );
	} Free(anc, 7) {}
}
// Function 8 with degree 1
// nq: 24, na: 7, ng: 2
void func8R(qbit **q, int n) {
printf("func8R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[5]; // interacting bits
	qbit *res[20];
	qbit *nq0[31];
	nb[0] = q[0];
	nb[1] = q[18];
	nb[2] = q[20];
	nb[3] = q[17];
	nb[4] = q[1];
	res[0] = q[11];
	res[1] = q[15];
	res[2] = q[18];
	res[3] = q[20];
	res[4] = q[14];
	res[5] = q[5];
	res[6] = q[21];
	res[7] = q[0];
	res[8] = q[7];
	res[9] = q[19];
	res[10] = q[16];
	res[11] = q[2];
	res[12] = q[4];
	res[13] = q[10];
	res[14] = q[8];
	res[15] = q[13];
	res[16] = q[17];
	res[17] = q[9];
	res[18] = q[3];
	res[19] = q[12];
	// Non-leaf function
	_computeModule(0, 7, 24, 22, 1, 2, 0);
	acquire(7, anc, 5, nb);
	nq0[0] = q[17];
	nq0[1] = q[14];
	nq0[2] = anc[2];
	nq0[3] = q[13];
	nq0[4] = q[2];
	nq0[5] = q[11];
	nq0[6] = q[20];
	nq0[7] = anc[0];
	nq0[8] = anc[1];
	nq0[9] = q[12];
	nq0[10] = q[10];
	nq0[11] = q[23];
	nq0[12] = q[16];
	nq0[13] = anc[4];
	nq0[14] = q[9];
	nq0[15] = q[21];
	nq0[16] = q[1];
	nq0[17] = q[15];
	nq0[18] = q[6];
	nq0[19] = q[8];
	nq0[20] = anc[3];
	nq0[21] = q[4];
	nq0[22] = q[0];
	nq0[23] = q[18];
	nq0[24] = anc[5];
	nq0[25] = q[19];
	nq0[26] = q[22];
	nq0[27] = q[7];
	nq0[28] = q[3];
	nq0[29] = anc[6];
	nq0[30] = q[5];
	Recompute(res, 0, anc, 7, 24, 22){
		CNOT( q[0], q[18] );
		Toffoli( q[20], q[17], q[1] );
		func15(nq0, 31);
	}
	Restore {
		CNOT( q[23], res[0] );
		CNOT( anc[0], res[1] );
		CNOT( q[22], res[2] );
		CNOT( q[14], res[3] );
		CNOT( q[13], res[4] );
		CNOT( anc[3], res[5] );
		CNOT( q[11], res[6] );
		CNOT( q[8], res[7] );
		CNOT( q[2], res[8] );
		CNOT( q[18], res[9] );
		CNOT( q[6], res[10] );
		CNOT( q[20], res[11] );
		CNOT( q[0], res[12] );
		CNOT( q[1], res[13] );
		CNOT( anc[6], res[14] );
		CNOT( q[16], res[15] );
		CNOT( q[10], res[16] );
		CNOT( anc[5], res[17] );
		CNOT( q[17], res[18] );
		CNOT( q[5], res[19] );
	}
	Unrecompute {
		func15R(nq0, 31);
		Toffoli( q[20], q[17], q[1] );
		CNOT( q[0], q[18] );
	} Refree(anc, 7) {}
}
// Function 7 with degree 0
// nq: 24, na: 3, ng: 4
void func7(qbit **q, int n) {
printf("func7\n");
fflush(stderr);
	qbit *anc[3]; // ancilla
	qbit *nb[8]; // interacting bits
	qbit *res[2];
	nb[0] = q[11];
	nb[1] = q[22];
	nb[2] = q[2];
	nb[3] = q[13];
	nb[4] = q[2];
	nb[5] = q[9];
	nb[6] = q[15];
	nb[7] = q[18];
	res[0] = q[6];
	res[1] = q[21];
	// Leaf function
	Compute (0, 3, 10, 6, 0, 2, 0) {
		acquire(3, anc, 8, nb);
		Toffoli( q[11], q[22], q[2] );
		Toffoli( q[13], q[2], q[9] );
		CNOT( q[15], anc[2] );
		CNOT( anc[1], q[18] );
	}
	Store {
		CNOT( q[21], res[0] );
		CNOT( q[16], res[1] );
	}
	Uncompute(res, 0, anc, 3, 10, 6){
		CNOT( anc[1], q[18] );
		CNOT( q[15], anc[2] );
		Toffoli( q[13], q[2], q[9] );
		Toffoli( q[11], q[22], q[2] );
	} Free(anc, 3) {}
}
// Function 7 with degree 0
// nq: 24, na: 3, ng: 4
void func7R(qbit **q, int n) {
printf("func7R\n");
fflush(stderr);
	qbit *anc[3]; // ancilla
	qbit *nb[8]; // interacting bits
	qbit *res[2];
	nb[0] = q[11];
	nb[1] = q[22];
	nb[2] = q[2];
	nb[3] = q[13];
	nb[4] = q[2];
	nb[5] = q[9];
	nb[6] = q[15];
	nb[7] = q[18];
	res[0] = q[6];
	res[1] = q[21];
	// Leaf function
	_computeModule(0, 3, 10, 6, 0, 2, 0);
	acquire(3, anc, 8, nb);
	Recompute (res, 0, anc, 3, 10, 6){
		CNOT( anc[1], q[18] );
		CNOT( q[15], anc[2] );
		Toffoli( q[13], q[2], q[9] );
		Toffoli( q[11], q[22], q[2] );
	}
	Restore {
		CNOT( q[21], res[0] );
		CNOT( q[16], res[1] );
	}
	Unrecompute {
		Toffoli( q[11], q[22], q[2] );
		Toffoli( q[13], q[2], q[9] );
		CNOT( q[15], anc[2] );
		CNOT( anc[1], q[18] );
	} Refree(anc, 3) {}
}
// Function 6 with degree 1
// nq: 15, na: 2, ng: 5
void func6(qbit **q, int n) {
printf("func6\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[12]; // interacting bits
	qbit *res[4];
	qbit *nq0[17];
	nb[0] = q[13];
	nb[1] = q[2];
	nb[2] = q[12];
	nb[3] = q[14];
	nb[4] = q[13];
	nb[5] = q[11];
	nb[6] = q[3];
	nb[7] = q[7];
	nb[8] = q[11];
	nb[9] = q[6];
	nb[10] = q[0];
	nb[11] = q[13];
	res[0] = q[4];
	res[1] = q[1];
	res[2] = q[11];
	res[3] = q[6];
	// Non-leaf function
	Compute (0, 2, 14, 9, 1, 3, 0){
		acquire(2, anc, 12, nb);
	nq0[0] = q[1];
	nq0[1] = q[9];
	nq0[2] = q[6];
	nq0[3] = q[4];
	nq0[4] = q[14];
	nq0[5] = q[12];
	nq0[6] = q[7];
	nq0[7] = anc[0];
	nq0[8] = q[2];
	nq0[9] = q[5];
	nq0[10] = q[0];
	nq0[11] = q[8];
	nq0[12] = q[3];
	nq0[13] = q[13];
	nq0[14] = q[10];
	nq0[15] = anc[1];
	nq0[16] = q[11];
		CNOT( q[12], q[14] );
		CNOT( q[7], q[11] );
		Toffoli( q[6], q[0], q[13] );
		func14(nq0, 17);
		CNOT( q[13], q[2] );
		Toffoli( q[13], q[11], q[3] );
	}
	Store {
		CNOT( q[11], res[0] );
		CNOT( q[14], res[1] );
		CNOT( q[0], res[2] );
		CNOT( q[1], res[3] );
	}
	Uncompute(res, 0, anc, 2, 14, 9){
		Toffoli( q[13], q[11], q[3] );
		CNOT( q[13], q[2] );
		func14R(nq0, 17);
		Toffoli( q[6], q[0], q[13] );
		CNOT( q[7], q[11] );
		CNOT( q[12], q[14] );
	} Free(anc, 2) {}
}
// Function 6 with degree 1
// nq: 15, na: 2, ng: 5
void func6R(qbit **q, int n) {
printf("func6R\n");
fflush(stderr);
	qbit *anc[2]; // ancilla
	qbit *nb[12]; // interacting bits
	qbit *res[4];
	qbit *nq0[17];
	nb[0] = q[13];
	nb[1] = q[2];
	nb[2] = q[12];
	nb[3] = q[14];
	nb[4] = q[13];
	nb[5] = q[11];
	nb[6] = q[3];
	nb[7] = q[7];
	nb[8] = q[11];
	nb[9] = q[6];
	nb[10] = q[0];
	nb[11] = q[13];
	res[0] = q[4];
	res[1] = q[1];
	res[2] = q[11];
	res[3] = q[6];
	// Non-leaf function
	_computeModule(0, 2, 14, 9, 1, 3, 0);
	acquire(2, anc, 12, nb);
	nq0[0] = q[1];
	nq0[1] = q[9];
	nq0[2] = q[6];
	nq0[3] = q[4];
	nq0[4] = q[14];
	nq0[5] = q[12];
	nq0[6] = q[7];
	nq0[7] = anc[0];
	nq0[8] = q[2];
	nq0[9] = q[5];
	nq0[10] = q[0];
	nq0[11] = q[8];
	nq0[12] = q[3];
	nq0[13] = q[13];
	nq0[14] = q[10];
	nq0[15] = anc[1];
	nq0[16] = q[11];
	Recompute(res, 0, anc, 2, 14, 9){
		CNOT( q[12], q[14] );
		CNOT( q[7], q[11] );
		Toffoli( q[6], q[0], q[13] );
		func14(nq0, 17);
		CNOT( q[13], q[2] );
		Toffoli( q[13], q[11], q[3] );
	}
	Restore {
		CNOT( q[11], res[0] );
		CNOT( q[14], res[1] );
		CNOT( q[0], res[2] );
		CNOT( q[1], res[3] );
	}
	Unrecompute {
		Toffoli( q[13], q[11], q[3] );
		CNOT( q[13], q[2] );
		func14R(nq0, 17);
		Toffoli( q[6], q[0], q[13] );
		CNOT( q[7], q[11] );
		CNOT( q[12], q[14] );
	} Refree(anc, 2) {}
}
// Function 5 with degree 3
// nq: 15, na: 6, ng: 3
void func5(qbit **q, int n) {
printf("func5\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[3]; // interacting bits
	qbit *res[14];
	qbit *nq0[7];
	qbit *nq1[7];
	qbit *nq2[7];
	nb[0] = q[10];
	nb[1] = q[11];
	nb[2] = q[1];
	res[0] = q[1];
	res[1] = q[5];
	res[2] = q[10];
	res[3] = q[13];
	res[4] = q[4];
	res[5] = q[8];
	res[6] = q[0];
	res[7] = q[7];
	res[8] = q[2];
	res[9] = q[11];
	res[10] = q[9];
	res[11] = q[14];
	res[12] = q[12];
	res[13] = q[6];
	// Non-leaf function
	Compute (0, 6, 20, 17, 3, 3, 0){
		acquire(6, anc, 3, nb);
	nq0[0] = q[10];
	nq0[1] = q[6];
	nq0[2] = q[0];
	nq0[3] = q[9];
	nq0[4] = q[13];
	nq0[5] = q[3];
	nq0[6] = q[2];
	nq1[0] = anc[3];
	nq1[1] = anc[1];
	nq1[2] = anc[5];
	nq1[3] = q[12];
	nq1[4] = q[8];
	nq1[5] = q[11];
	nq1[6] = q[5];
	nq2[0] = q[4];
	nq2[1] = anc[2];
	nq2[2] = anc[4];
	nq2[3] = q[7];
	nq2[4] = q[1];
	nq2[5] = q[14];
	nq2[6] = anc[0];
		func13(nq2, 7);
		Toffoli( anc[2], anc[3], q[1] );
		func11(nq0, 7);
		CNOT( q[11], anc[0] );
		Toffoli( anc[5], q[10], anc[4] );
		func12(nq1, 7);
	}
	Store {
		CNOT( anc[1], res[0] );
		CNOT( q[4], res[1] );
		CNOT( q[8], res[2] );
		CNOT( anc[5], res[3] );
		CNOT( q[13], res[4] );
		CNOT( q[11], res[5] );
		CNOT( q[1], res[6] );
		CNOT( anc[4], res[7] );
		CNOT( q[7], res[8] );
		CNOT( q[2], res[9] );
		CNOT( anc[0], res[10] );
		CNOT( q[6], res[11] );
		CNOT( q[14], res[12] );
		CNOT( q[10], res[13] );
	}
	Uncompute(res, 0, anc, 6, 20, 17){
		func12R(nq1, 7);
		Toffoli( anc[5], q[10], anc[4] );
		CNOT( q[11], anc[0] );
		func11R(nq0, 7);
		Toffoli( anc[2], anc[3], q[1] );
		func13R(nq2, 7);
	} Free(anc, 6) {}
}
// Function 5 with degree 3
// nq: 15, na: 6, ng: 3
void func5R(qbit **q, int n) {
printf("func5R\n");
fflush(stderr);
	qbit *anc[6]; // ancilla
	qbit *nb[3]; // interacting bits
	qbit *res[14];
	qbit *nq0[7];
	qbit *nq1[7];
	qbit *nq2[7];
	nb[0] = q[10];
	nb[1] = q[11];
	nb[2] = q[1];
	res[0] = q[1];
	res[1] = q[5];
	res[2] = q[10];
	res[3] = q[13];
	res[4] = q[4];
	res[5] = q[8];
	res[6] = q[0];
	res[7] = q[7];
	res[8] = q[2];
	res[9] = q[11];
	res[10] = q[9];
	res[11] = q[14];
	res[12] = q[12];
	res[13] = q[6];
	// Non-leaf function
	_computeModule(0, 6, 20, 17, 3, 3, 0);
	acquire(6, anc, 3, nb);
	nq0[0] = q[10];
	nq0[1] = q[6];
	nq0[2] = q[0];
	nq0[3] = q[9];
	nq0[4] = q[13];
	nq0[5] = q[3];
	nq0[6] = q[2];
	nq1[0] = anc[3];
	nq1[1] = anc[1];
	nq1[2] = anc[5];
	nq1[3] = q[12];
	nq1[4] = q[8];
	nq1[5] = q[11];
	nq1[6] = q[5];
	nq2[0] = q[4];
	nq2[1] = anc[2];
	nq2[2] = anc[4];
	nq2[3] = q[7];
	nq2[4] = q[1];
	nq2[5] = q[14];
	nq2[6] = anc[0];
	Recompute(res, 0, anc, 6, 20, 17){
		func13(nq2, 7);
		Toffoli( anc[2], anc[3], q[1] );
		func11(nq0, 7);
		CNOT( q[11], anc[0] );
		Toffoli( anc[5], q[10], anc[4] );
		func12(nq1, 7);
	}
	Restore {
		CNOT( anc[1], res[0] );
		CNOT( q[4], res[1] );
		CNOT( q[8], res[2] );
		CNOT( anc[5], res[3] );
		CNOT( q[13], res[4] );
		CNOT( q[11], res[5] );
		CNOT( q[1], res[6] );
		CNOT( anc[4], res[7] );
		CNOT( q[7], res[8] );
		CNOT( q[2], res[9] );
		CNOT( anc[0], res[10] );
		CNOT( q[6], res[11] );
		CNOT( q[14], res[12] );
		CNOT( q[10], res[13] );
	}
	Unrecompute {
		func12R(nq1, 7);
		Toffoli( anc[5], q[10], anc[4] );
		CNOT( q[11], anc[0] );
		func11R(nq0, 7);
		Toffoli( anc[2], anc[3], q[1] );
		func13R(nq2, 7);
	} Refree(anc, 6) {}
}
// Function 4 with degree 2
// nq: 15, na: 3, ng: 6
void func4(qbit **q, int n) {
printf("func4\n");
fflush(stderr);
	qbit *anc[3]; // ancilla
	qbit *nb[12]; // interacting bits
	qbit *res[15];
	qbit *nq0[9];
	qbit *nq1[9];
	nb[0] = q[13];
	nb[1] = q[13];
	nb[2] = q[2];
	nb[3] = q[8];
	nb[4] = q[6];
	nb[5] = q[0];
	nb[6] = q[3];
	nb[7] = q[12];
	nb[8] = q[11];
	nb[9] = q[10];
	nb[10] = q[12];
	nb[11] = q[11];
	res[0] = q[6];
	res[1] = q[8];
	res[2] = q[12];
	res[3] = q[14];
	res[4] = q[0];
	res[5] = q[11];
	res[6] = q[2];
	res[7] = q[9];
	res[8] = q[10];
	res[9] = q[13];
	res[10] = q[5];
	res[11] = q[4];
	res[12] = q[3];
	res[13] = q[1];
	res[14] = q[7];
	// Non-leaf function
	Compute (0, 3, 27, 21, 2, 3, 0){
		acquire(3, anc, 12, nb);
	nq0[0] = q[11];
	nq0[1] = q[6];
	nq0[2] = q[12];
	nq0[3] = anc[1];
	nq0[4] = anc[2];
	nq0[5] = q[5];
	nq0[6] = anc[0];
	nq0[7] = q[10];
	nq0[8] = q[7];
	nq1[0] = q[2];
	nq1[1] = q[9];
	nq1[2] = q[0];
	nq1[3] = q[4];
	nq1[4] = q[14];
	nq1[5] = q[8];
	nq1[6] = q[1];
	nq1[7] = q[13];
	nq1[8] = q[3];
		Toffoli( q[10], q[12], q[11] );
		CNOT( q[8], q[6] );
		CNOT( q[13], anc[2] );
		func10(nq1, 9);
		CNOT( q[12], q[11] );
		Toffoli( anc[2], q[0], q[3] );
		Toffoli( q[13], q[2], anc[0] );
		func9(nq0, 9);
	}
	Store {
		CNOT( anc[0], res[0] );
		CNOT( q[10], res[1] );
		CNOT( anc[0], res[2] );
		CNOT( q[1], res[3] );
		CNOT( q[2], res[4] );
		CNOT( q[5], res[5] );
		CNOT( q[3], res[6] );
		CNOT( q[13], res[7] );
		CNOT( q[11], res[8] );
		CNOT( q[7], res[9] );
		CNOT( q[14], res[10] );
		CNOT( anc[1], res[11] );
		CNOT( q[0], res[12] );
		CNOT( anc[2], res[13] );
		CNOT( q[4], res[14] );
	}
	Uncompute(res, 0, anc, 3, 27, 21){
		func9R(nq0, 9);
		Toffoli( q[13], q[2], anc[0] );
		Toffoli( anc[2], q[0], q[3] );
		CNOT( q[12], q[11] );
		func10R(nq1, 9);
		CNOT( q[13], anc[2] );
		CNOT( q[8], q[6] );
		Toffoli( q[10], q[12], q[11] );
	} Free(anc, 3) {}
}
// Function 4 with degree 2
// nq: 15, na: 3, ng: 6
void func4R(qbit **q, int n) {
printf("func4R\n");
fflush(stderr);
	qbit *anc[3]; // ancilla
	qbit *nb[12]; // interacting bits
	qbit *res[15];
	qbit *nq0[9];
	qbit *nq1[9];
	nb[0] = q[13];
	nb[1] = q[13];
	nb[2] = q[2];
	nb[3] = q[8];
	nb[4] = q[6];
	nb[5] = q[0];
	nb[6] = q[3];
	nb[7] = q[12];
	nb[8] = q[11];
	nb[9] = q[10];
	nb[10] = q[12];
	nb[11] = q[11];
	res[0] = q[6];
	res[1] = q[8];
	res[2] = q[12];
	res[3] = q[14];
	res[4] = q[0];
	res[5] = q[11];
	res[6] = q[2];
	res[7] = q[9];
	res[8] = q[10];
	res[9] = q[13];
	res[10] = q[5];
	res[11] = q[4];
	res[12] = q[3];
	res[13] = q[1];
	res[14] = q[7];
	// Non-leaf function
	_computeModule(0, 3, 27, 21, 2, 3, 0);
	acquire(3, anc, 12, nb);
	nq0[0] = q[11];
	nq0[1] = q[6];
	nq0[2] = q[12];
	nq0[3] = anc[1];
	nq0[4] = anc[2];
	nq0[5] = q[5];
	nq0[6] = anc[0];
	nq0[7] = q[10];
	nq0[8] = q[7];
	nq1[0] = q[2];
	nq1[1] = q[9];
	nq1[2] = q[0];
	nq1[3] = q[4];
	nq1[4] = q[14];
	nq1[5] = q[8];
	nq1[6] = q[1];
	nq1[7] = q[13];
	nq1[8] = q[3];
	Recompute(res, 0, anc, 3, 27, 21){
		Toffoli( q[10], q[12], q[11] );
		CNOT( q[8], q[6] );
		CNOT( q[13], anc[2] );
		func10(nq1, 9);
		CNOT( q[12], q[11] );
		Toffoli( anc[2], q[0], q[3] );
		Toffoli( q[13], q[2], anc[0] );
		func9(nq0, 9);
	}
	Restore {
		CNOT( anc[0], res[0] );
		CNOT( q[10], res[1] );
		CNOT( anc[0], res[2] );
		CNOT( q[1], res[3] );
		CNOT( q[2], res[4] );
		CNOT( q[5], res[5] );
		CNOT( q[3], res[6] );
		CNOT( q[13], res[7] );
		CNOT( q[11], res[8] );
		CNOT( q[7], res[9] );
		CNOT( q[14], res[10] );
		CNOT( anc[1], res[11] );
		CNOT( q[0], res[12] );
		CNOT( anc[2], res[13] );
		CNOT( q[4], res[14] );
	}
	Unrecompute {
		func9R(nq0, 9);
		Toffoli( q[13], q[2], anc[0] );
		Toffoli( anc[2], q[0], q[3] );
		CNOT( q[12], q[11] );
		func10R(nq1, 9);
		CNOT( q[13], anc[2] );
		CNOT( q[8], q[6] );
		Toffoli( q[10], q[12], q[11] );
	} Refree(anc, 3) {}
}
// Function 3 with degree 0
// nq: 42, na: 7, ng: 7
void func3(qbit **q, int n) {
printf("func3\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[13]; // interacting bits
	qbit *res[42];
	nb[0] = q[23];
	nb[1] = q[31];
	nb[2] = q[37];
	nb[3] = q[21];
	nb[4] = q[4];
	nb[5] = q[23];
	nb[6] = q[32];
	nb[7] = q[12];
	nb[8] = q[19];
	nb[9] = q[33];
	nb[10] = q[29];
	nb[11] = q[38];
	nb[12] = q[34];
	res[0] = q[40];
	res[1] = q[34];
	res[2] = q[16];
	res[3] = q[10];
	res[4] = q[9];
	res[5] = q[19];
	res[6] = q[15];
	res[7] = q[18];
	res[8] = q[4];
	res[9] = q[29];
	res[10] = q[12];
	res[11] = q[2];
	res[12] = q[41];
	res[13] = q[32];
	res[14] = q[26];
	res[15] = q[24];
	res[16] = q[33];
	res[17] = q[27];
	res[18] = q[36];
	res[19] = q[17];
	res[20] = q[13];
	res[21] = q[35];
	res[22] = q[1];
	res[23] = q[5];
	res[24] = q[20];
	res[25] = q[23];
	res[26] = q[14];
	res[27] = q[21];
	res[28] = q[39];
	res[29] = q[8];
	res[30] = q[37];
	res[31] = q[7];
	res[32] = q[6];
	res[33] = q[3];
	res[34] = q[0];
	res[35] = q[28];
	res[36] = q[25];
	res[37] = q[11];
	res[38] = q[22];
	res[39] = q[38];
	res[40] = q[30];
	res[41] = q[31];
	// Leaf function
	Compute (0, 7, 56, 49, 0, 96, 0) {
		acquire(7, anc, 13, nb);
		Toffoli( q[23], q[31], anc[2] );
		Toffoli( anc[6], anc[2], q[37] );
		CNOT( q[21], q[4] );
		CNOT( q[23], q[32] );
		Toffoli( q[12], anc[5], q[19] );
		Toffoli( q[33], q[29], anc[2] );
		CNOT( q[38], q[34] );
	}
	Store {
		CNOT( q[31], res[0] );
		CNOT( q[40], res[1] );
		CNOT( q[28], res[2] );
		CNOT( q[4], res[3] );
		CNOT( q[10], res[4] );
		CNOT( q[27], res[5] );
		CNOT( anc[5], res[6] );
		CNOT( q[33], res[7] );
		CNOT( q[25], res[8] );
		CNOT( q[24], res[9] );
		CNOT( q[2], res[10] );
		CNOT( q[22], res[11] );
		CNOT( anc[3], res[12] );
		CNOT( anc[5], res[13] );
		CNOT( q[20], res[14] );
		CNOT( q[26], res[15] );
		CNOT( q[18], res[16] );
		CNOT( anc[2], res[17] );
		CNOT( q[21], res[18] );
		CNOT( q[15], res[19] );
		CNOT( q[14], res[20] );
		CNOT( q[8], res[21] );
		CNOT( q[6], res[22] );
		CNOT( anc[2], res[23] );
		CNOT( q[35], res[24] );
		CNOT( q[3], res[25] );
		CNOT( q[23], res[26] );
		CNOT( q[16], res[27] );
		CNOT( anc[1], res[28] );
		CNOT( q[17], res[29] );
		CNOT( anc[4], res[30] );
		CNOT( q[12], res[31] );
		CNOT( q[11], res[32] );
		CNOT( q[1], res[33] );
		CNOT( q[30], res[34] );
		CNOT( q[19], res[35] );
		CNOT( q[13], res[36] );
		CNOT( q[41], res[37] );
		CNOT( anc[0], res[38] );
		CNOT( q[36], res[39] );
		CNOT( q[38], res[40] );
		CNOT( q[0], res[41] );
	}
	Uncompute(res, 0, anc, 7, 56, 49){
		CNOT( q[38], q[34] );
		Toffoli( q[33], q[29], anc[2] );
		Toffoli( q[12], anc[5], q[19] );
		CNOT( q[23], q[32] );
		CNOT( q[21], q[4] );
		Toffoli( anc[6], anc[2], q[37] );
		Toffoli( q[23], q[31], anc[2] );
	} Free(anc, 7) {}
}
// Function 3 with degree 0
// nq: 42, na: 7, ng: 7
void func3R(qbit **q, int n) {
printf("func3R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[13]; // interacting bits
	qbit *res[42];
	nb[0] = q[23];
	nb[1] = q[31];
	nb[2] = q[37];
	nb[3] = q[21];
	nb[4] = q[4];
	nb[5] = q[23];
	nb[6] = q[32];
	nb[7] = q[12];
	nb[8] = q[19];
	nb[9] = q[33];
	nb[10] = q[29];
	nb[11] = q[38];
	nb[12] = q[34];
	res[0] = q[40];
	res[1] = q[34];
	res[2] = q[16];
	res[3] = q[10];
	res[4] = q[9];
	res[5] = q[19];
	res[6] = q[15];
	res[7] = q[18];
	res[8] = q[4];
	res[9] = q[29];
	res[10] = q[12];
	res[11] = q[2];
	res[12] = q[41];
	res[13] = q[32];
	res[14] = q[26];
	res[15] = q[24];
	res[16] = q[33];
	res[17] = q[27];
	res[18] = q[36];
	res[19] = q[17];
	res[20] = q[13];
	res[21] = q[35];
	res[22] = q[1];
	res[23] = q[5];
	res[24] = q[20];
	res[25] = q[23];
	res[26] = q[14];
	res[27] = q[21];
	res[28] = q[39];
	res[29] = q[8];
	res[30] = q[37];
	res[31] = q[7];
	res[32] = q[6];
	res[33] = q[3];
	res[34] = q[0];
	res[35] = q[28];
	res[36] = q[25];
	res[37] = q[11];
	res[38] = q[22];
	res[39] = q[38];
	res[40] = q[30];
	res[41] = q[31];
	// Leaf function
	_computeModule(0, 7, 56, 49, 0, 96, 0);
	acquire(7, anc, 13, nb);
	Recompute (res, 0, anc, 7, 56, 49){
		CNOT( q[38], q[34] );
		Toffoli( q[33], q[29], anc[2] );
		Toffoli( q[12], anc[5], q[19] );
		CNOT( q[23], q[32] );
		CNOT( q[21], q[4] );
		Toffoli( anc[6], anc[2], q[37] );
		Toffoli( q[23], q[31], anc[2] );
	}
	Restore {
		CNOT( q[31], res[0] );
		CNOT( q[40], res[1] );
		CNOT( q[28], res[2] );
		CNOT( q[4], res[3] );
		CNOT( q[10], res[4] );
		CNOT( q[27], res[5] );
		CNOT( anc[5], res[6] );
		CNOT( q[33], res[7] );
		CNOT( q[25], res[8] );
		CNOT( q[24], res[9] );
		CNOT( q[2], res[10] );
		CNOT( q[22], res[11] );
		CNOT( anc[3], res[12] );
		CNOT( anc[5], res[13] );
		CNOT( q[20], res[14] );
		CNOT( q[26], res[15] );
		CNOT( q[18], res[16] );
		CNOT( anc[2], res[17] );
		CNOT( q[21], res[18] );
		CNOT( q[15], res[19] );
		CNOT( q[14], res[20] );
		CNOT( q[8], res[21] );
		CNOT( q[6], res[22] );
		CNOT( anc[2], res[23] );
		CNOT( q[35], res[24] );
		CNOT( q[3], res[25] );
		CNOT( q[23], res[26] );
		CNOT( q[16], res[27] );
		CNOT( anc[1], res[28] );
		CNOT( q[17], res[29] );
		CNOT( anc[4], res[30] );
		CNOT( q[12], res[31] );
		CNOT( q[11], res[32] );
		CNOT( q[1], res[33] );
		CNOT( q[30], res[34] );
		CNOT( q[19], res[35] );
		CNOT( q[13], res[36] );
		CNOT( q[41], res[37] );
		CNOT( anc[0], res[38] );
		CNOT( q[36], res[39] );
		CNOT( q[38], res[40] );
		CNOT( q[0], res[41] );
	}
	Unrecompute {
		Toffoli( q[23], q[31], anc[2] );
		Toffoli( anc[6], anc[2], q[37] );
		CNOT( q[21], q[4] );
		CNOT( q[23], q[32] );
		Toffoli( q[12], anc[5], q[19] );
		Toffoli( q[33], q[29], anc[2] );
		CNOT( q[38], q[34] );
	} Refree(anc, 7) {}
}
// Function 2 with degree 2
// nq: 42, na: 7, ng: 2
void func2(qbit **q, int n) {
printf("func2\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[5]; // interacting bits
	qbit *res[20];
	qbit *nq0[24];
	qbit *nq1[24];
	nb[0] = q[20];
	nb[1] = q[31];
	nb[2] = q[30];
	nb[3] = q[35];
	nb[4] = q[40];
	res[0] = q[3];
	res[1] = q[22];
	res[2] = q[36];
	res[3] = q[7];
	res[4] = q[35];
	res[5] = q[5];
	res[6] = q[31];
	res[7] = q[2];
	res[8] = q[0];
	res[9] = q[41];
	res[10] = q[19];
	res[11] = q[14];
	res[12] = q[18];
	res[13] = q[26];
	res[14] = q[16];
	res[15] = q[38];
	res[16] = q[1];
	res[17] = q[28];
	res[18] = q[40];
	res[19] = q[39];
	// Non-leaf function
	Compute (0, 7, 24, 22, 2, 96, 0){
		acquire(7, anc, 5, nb);
	nq0[0] = q[35];
	nq0[1] = q[2];
	nq0[2] = q[34];
	nq0[3] = q[41];
	nq0[4] = q[11];
	nq0[5] = q[19];
	nq0[6] = q[25];
	nq0[7] = anc[5];
	nq0[8] = q[1];
	nq0[9] = q[14];
	nq0[10] = q[26];
	nq0[11] = q[29];
	nq0[12] = q[7];
	nq0[13] = q[21];
	nq0[14] = q[37];
	nq0[15] = q[23];
	nq0[16] = q[31];
	nq0[17] = q[32];
	nq0[18] = q[28];
	nq0[19] = q[22];
	nq0[20] = anc[6];
	nq0[21] = anc[0];
	nq0[22] = q[6];
	nq0[23] = q[24];
	nq1[0] = q[5];
	nq1[1] = q[12];
	nq1[2] = q[4];
	nq1[3] = q[13];
	nq1[4] = q[18];
	nq1[5] = q[10];
	nq1[6] = q[40];
	nq1[7] = q[8];
	nq1[8] = q[38];
	nq1[9] = q[20];
	nq1[10] = anc[4];
	nq1[11] = q[16];
	nq1[12] = anc[2];
	nq1[13] = anc[1];
	nq1[14] = q[3];
	nq1[15] = q[30];
	nq1[16] = q[9];
	nq1[17] = q[17];
	nq1[18] = q[36];
	nq1[19] = q[33];
	nq1[20] = q[27];
	nq1[21] = anc[3];
	nq1[22] = q[15];
	nq1[23] = q[0];
		func8(nq1, 24);
		Toffoli( q[20], q[31], q[30] );
		CNOT( q[35], q[40] );
		func7(nq0, 24);
	}
	Store {
		CNOT( q[18], res[0] );
		CNOT( q[1], res[1] );
		CNOT( anc[6], res[2] );
		CNOT( q[11], res[3] );
		CNOT( q[8], res[4] );
		CNOT( q[12], res[5] );
		CNOT( anc[3], res[6] );
		CNOT( q[40], res[7] );
		CNOT( q[28], res[8] );
		CNOT( q[39], res[9] );
		CNOT( anc[2], res[10] );
		CNOT( q[2], res[11] );
		CNOT( q[24], res[12] );
		CNOT( q[19], res[13] );
		CNOT( q[0], res[14] );
		CNOT( q[7], res[15] );
		CNOT( q[3], res[16] );
		CNOT( q[35], res[17] );
		CNOT( q[37], res[18] );
		CNOT( q[14], res[19] );
	}
	Uncompute(res, 0, anc, 7, 24, 22){
		func7R(nq0, 24);
		CNOT( q[35], q[40] );
		Toffoli( q[20], q[31], q[30] );
		func8R(nq1, 24);
	} Free(anc, 7) {}
}
// Function 2 with degree 2
// nq: 42, na: 7, ng: 2
void func2R(qbit **q, int n) {
printf("func2R\n");
fflush(stderr);
	qbit *anc[7]; // ancilla
	qbit *nb[5]; // interacting bits
	qbit *res[20];
	qbit *nq0[24];
	qbit *nq1[24];
	nb[0] = q[20];
	nb[1] = q[31];
	nb[2] = q[30];
	nb[3] = q[35];
	nb[4] = q[40];
	res[0] = q[3];
	res[1] = q[22];
	res[2] = q[36];
	res[3] = q[7];
	res[4] = q[35];
	res[5] = q[5];
	res[6] = q[31];
	res[7] = q[2];
	res[8] = q[0];
	res[9] = q[41];
	res[10] = q[19];
	res[11] = q[14];
	res[12] = q[18];
	res[13] = q[26];
	res[14] = q[16];
	res[15] = q[38];
	res[16] = q[1];
	res[17] = q[28];
	res[18] = q[40];
	res[19] = q[39];
	// Non-leaf function
	_computeModule(0, 7, 24, 22, 2, 96, 0);
	acquire(7, anc, 5, nb);
	nq0[0] = q[35];
	nq0[1] = q[2];
	nq0[2] = q[34];
	nq0[3] = q[41];
	nq0[4] = q[11];
	nq0[5] = q[19];
	nq0[6] = q[25];
	nq0[7] = anc[5];
	nq0[8] = q[1];
	nq0[9] = q[14];
	nq0[10] = q[26];
	nq0[11] = q[29];
	nq0[12] = q[7];
	nq0[13] = q[21];
	nq0[14] = q[37];
	nq0[15] = q[23];
	nq0[16] = q[31];
	nq0[17] = q[32];
	nq0[18] = q[28];
	nq0[19] = q[22];
	nq0[20] = anc[6];
	nq0[21] = anc[0];
	nq0[22] = q[6];
	nq0[23] = q[24];
	nq1[0] = q[5];
	nq1[1] = q[12];
	nq1[2] = q[4];
	nq1[3] = q[13];
	nq1[4] = q[18];
	nq1[5] = q[10];
	nq1[6] = q[40];
	nq1[7] = q[8];
	nq1[8] = q[38];
	nq1[9] = q[20];
	nq1[10] = anc[4];
	nq1[11] = q[16];
	nq1[12] = anc[2];
	nq1[13] = anc[1];
	nq1[14] = q[3];
	nq1[15] = q[30];
	nq1[16] = q[9];
	nq1[17] = q[17];
	nq1[18] = q[36];
	nq1[19] = q[33];
	nq1[20] = q[27];
	nq1[21] = anc[3];
	nq1[22] = q[15];
	nq1[23] = q[0];
	Recompute(res, 0, anc, 7, 24, 22){
		func8(nq1, 24);
		Toffoli( q[20], q[31], q[30] );
		CNOT( q[35], q[40] );
		func7(nq0, 24);
	}
	Restore {
		CNOT( q[18], res[0] );
		CNOT( q[1], res[1] );
		CNOT( anc[6], res[2] );
		CNOT( q[11], res[3] );
		CNOT( q[8], res[4] );
		CNOT( q[12], res[5] );
		CNOT( anc[3], res[6] );
		CNOT( q[40], res[7] );
		CNOT( q[28], res[8] );
		CNOT( q[39], res[9] );
		CNOT( anc[2], res[10] );
		CNOT( q[2], res[11] );
		CNOT( q[24], res[12] );
		CNOT( q[19], res[13] );
		CNOT( q[0], res[14] );
		CNOT( q[7], res[15] );
		CNOT( q[3], res[16] );
		CNOT( q[35], res[17] );
		CNOT( q[37], res[18] );
		CNOT( q[14], res[19] );
	}
	Unrecompute {
		func7R(nq0, 24);
		CNOT( q[35], q[40] );
		Toffoli( q[20], q[31], q[30] );
		func8R(nq1, 24);
	} Refree(anc, 7) {}
}
// Function 1 with degree 3
// nq: 42, na: 4, ng: 7
void func1(qbit **q, int n) {
printf("func1\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[15]; // interacting bits
	qbit *res[15];
	qbit *nq0[15];
	qbit *nq1[15];
	qbit *nq2[15];
	nb[0] = q[34];
	nb[1] = q[22];
	nb[2] = q[29];
	nb[3] = q[21];
	nb[4] = q[7];
	nb[5] = q[23];
	nb[6] = q[12];
	nb[7] = q[2];
	nb[8] = q[14];
	nb[9] = q[34];
	nb[10] = q[22];
	nb[11] = q[40];
	nb[12] = q[10];
	nb[13] = q[24];
	nb[14] = q[20];
	res[0] = q[27];
	res[1] = q[12];
	res[2] = q[40];
	res[3] = q[30];
	res[4] = q[41];
	res[5] = q[8];
	res[6] = q[22];
	res[7] = q[38];
	res[8] = q[17];
	res[9] = q[2];
	res[10] = q[35];
	res[11] = q[33];
	res[12] = q[26];
	res[13] = q[5];
	res[14] = q[11];
	// Non-leaf function
	Compute (0, 4, 29, 22, 3, 96, 0){
		acquire(4, anc, 15, nb);
	nq0[0] = q[22];
	nq0[1] = q[37];
	nq0[2] = q[0];
	nq0[3] = q[19];
	nq0[4] = q[40];
	nq0[5] = q[20];
	nq0[6] = q[15];
	nq0[7] = q[14];
	nq0[8] = q[23];
	nq0[9] = q[24];
	nq0[10] = q[34];
	nq0[11] = anc[2];
	nq0[12] = q[31];
	nq0[13] = q[6];
	nq0[14] = q[33];
	nq1[0] = q[27];
	nq1[1] = q[35];
	nq1[2] = q[10];
	nq1[3] = q[17];
	nq1[4] = q[8];
	nq1[5] = q[7];
	nq1[6] = q[36];
	nq1[7] = q[30];
	nq1[8] = q[41];
	nq1[9] = q[32];
	nq1[10] = q[16];
	nq1[11] = q[4];
	nq1[12] = q[26];
	nq1[13] = q[11];
	nq1[14] = q[18];
	nq2[0] = q[13];
	nq2[1] = q[25];
	nq2[2] = q[12];
	nq2[3] = q[5];
	nq2[4] = q[28];
	nq2[5] = q[9];
	nq2[6] = q[21];
	nq2[7] = anc[0];
	nq2[8] = anc[3];
	nq2[9] = anc[1];
	nq2[10] = q[39];
	nq2[11] = q[38];
	nq2[12] = q[29];
	nq2[13] = q[1];
	nq2[14] = q[3];
		Toffoli( q[7], q[23], q[12] );
		CNOT( q[29], q[21] );
		CNOT( q[2], q[14] );
		CNOT( q[40], q[10] );
		func5(nq1, 15);
		func6(nq2, 15);
		Toffoli( q[34], anc[0], q[22] );
		CNOT( q[24], q[20] );
		CNOT( q[34], q[22] );
		func4(nq0, 15);
	}
	Store {
		CNOT( q[0], res[0] );
		CNOT( q[39], res[1] );
		CNOT( q[33], res[2] );
		CNOT( q[15], res[3] );
		CNOT( q[7], res[4] );
		CNOT( q[26], res[5] );
		CNOT( anc[1], res[6] );
		CNOT( q[6], res[7] );
		CNOT( q[10], res[8] );
		CNOT( q[38], res[9] );
		CNOT( q[8], res[10] );
		CNOT( q[41], res[11] );
		CNOT( anc[2], res[12] );
		CNOT( q[13], res[13] );
		CNOT( q[28], res[14] );
	}
	Uncompute(res, 0, anc, 4, 29, 22){
		func4R(nq0, 15);
		CNOT( q[34], q[22] );
		CNOT( q[24], q[20] );
		Toffoli( q[34], anc[0], q[22] );
		func6R(nq2, 15);
		func5R(nq1, 15);
		CNOT( q[40], q[10] );
		CNOT( q[2], q[14] );
		CNOT( q[29], q[21] );
		Toffoli( q[7], q[23], q[12] );
	} Free(anc, 4) {}
}
// Function 1 with degree 3
// nq: 42, na: 4, ng: 7
void func1R(qbit **q, int n) {
printf("func1R\n");
fflush(stderr);
	qbit *anc[4]; // ancilla
	qbit *nb[15]; // interacting bits
	qbit *res[15];
	qbit *nq0[15];
	qbit *nq1[15];
	qbit *nq2[15];
	nb[0] = q[34];
	nb[1] = q[22];
	nb[2] = q[29];
	nb[3] = q[21];
	nb[4] = q[7];
	nb[5] = q[23];
	nb[6] = q[12];
	nb[7] = q[2];
	nb[8] = q[14];
	nb[9] = q[34];
	nb[10] = q[22];
	nb[11] = q[40];
	nb[12] = q[10];
	nb[13] = q[24];
	nb[14] = q[20];
	res[0] = q[27];
	res[1] = q[12];
	res[2] = q[40];
	res[3] = q[30];
	res[4] = q[41];
	res[5] = q[8];
	res[6] = q[22];
	res[7] = q[38];
	res[8] = q[17];
	res[9] = q[2];
	res[10] = q[35];
	res[11] = q[33];
	res[12] = q[26];
	res[13] = q[5];
	res[14] = q[11];
	// Non-leaf function
	_computeModule(0, 4, 29, 22, 3, 96, 0);
	acquire(4, anc, 15, nb);
	nq0[0] = q[22];
	nq0[1] = q[37];
	nq0[2] = q[0];
	nq0[3] = q[19];
	nq0[4] = q[40];
	nq0[5] = q[20];
	nq0[6] = q[15];
	nq0[7] = q[14];
	nq0[8] = q[23];
	nq0[9] = q[24];
	nq0[10] = q[34];
	nq0[11] = anc[2];
	nq0[12] = q[31];
	nq0[13] = q[6];
	nq0[14] = q[33];
	nq1[0] = q[27];
	nq1[1] = q[35];
	nq1[2] = q[10];
	nq1[3] = q[17];
	nq1[4] = q[8];
	nq1[5] = q[7];
	nq1[6] = q[36];
	nq1[7] = q[30];
	nq1[8] = q[41];
	nq1[9] = q[32];
	nq1[10] = q[16];
	nq1[11] = q[4];
	nq1[12] = q[26];
	nq1[13] = q[11];
	nq1[14] = q[18];
	nq2[0] = q[13];
	nq2[1] = q[25];
	nq2[2] = q[12];
	nq2[3] = q[5];
	nq2[4] = q[28];
	nq2[5] = q[9];
	nq2[6] = q[21];
	nq2[7] = anc[0];
	nq2[8] = anc[3];
	nq2[9] = anc[1];
	nq2[10] = q[39];
	nq2[11] = q[38];
	nq2[12] = q[29];
	nq2[13] = q[1];
	nq2[14] = q[3];
	Recompute(res, 0, anc, 4, 29, 22){
		Toffoli( q[7], q[23], q[12] );
		CNOT( q[29], q[21] );
		CNOT( q[2], q[14] );
		CNOT( q[40], q[10] );
		func5(nq1, 15);
		func6(nq2, 15);
		Toffoli( q[34], anc[0], q[22] );
		CNOT( q[24], q[20] );
		CNOT( q[34], q[22] );
		func4(nq0, 15);
	}
	Restore {
		CNOT( q[0], res[0] );
		CNOT( q[39], res[1] );
		CNOT( q[33], res[2] );
		CNOT( q[15], res[3] );
		CNOT( q[7], res[4] );
		CNOT( q[26], res[5] );
		CNOT( anc[1], res[6] );
		CNOT( q[6], res[7] );
		CNOT( q[10], res[8] );
		CNOT( q[38], res[9] );
		CNOT( q[8], res[10] );
		CNOT( q[41], res[11] );
		CNOT( anc[2], res[12] );
		CNOT( q[13], res[13] );
		CNOT( q[28], res[14] );
	}
	Unrecompute {
		func4R(nq0, 15);
		CNOT( q[34], q[22] );
		CNOT( q[24], q[20] );
		Toffoli( q[34], anc[0], q[22] );
		func6R(nq2, 15);
		func5R(nq1, 15);
		CNOT( q[40], q[10] );
		CNOT( q[2], q[14] );
		CNOT( q[29], q[21] );
		Toffoli( q[7], q[23], q[12] );
	} Refree(anc, 4) {}
}
// main function
int main() {
	qbit *new[128];
	acquire(128, new, 0, NULL);
	// Intialize inputs
	X (new[113]);
	X (new[99]);
	X (new[98]);
	X (new[36]);
	X (new[77]);
	X (new[91]);
	X (new[122]);
	X (new[59]);
	X (new[120]);
	X (new[44]);
	X (new[49]);
	X (new[6]);
	X (new[87]);
	X (new[93]);
	X (new[43]);
	X (new[24]);
	X (new[48]);
	X (new[50]);
	X (new[5]);
	X (new[114]);
	X (new[47]);
	X (new[20]);
	X (new[111]);
	X (new[95]);
	X (new[28]);
	X (new[88]);
	X (new[94]);
	X (new[96]);
	X (new[75]);
	X (new[31]);
	X (new[68]);
	X (new[71]);
	X (new[112]);
	X (new[107]);
	X (new[115]);
	X (new[74]);
	X (new[81]);
	X (new[58]);
	X (new[35]);
	X (new[61]);
	X (new[110]);
	X (new[72]);
	X (new[45]);
	X (new[53]);
	X (new[66]);
	X (new[124]);
	X (new[2]);
	X (new[127]);
	X (new[125]);
	X (new[51]);
	X (new[62]);
	X (new[106]);
	X (new[76]);
	X (new[30]);
	X (new[85]);
	X (new[69]);
	X (new[89]);
	X (new[1]);
	X (new[83]);
	X (new[65]);
	X (new[7]);
	X (new[12]);
	X (new[25]);
	X (new[11]);
	X (new[3]);
	X (new[78]);
	X (new[70]);
	X (new[18]);
	X (new[10]);
	X (new[17]);
	X (new[0]);
	X (new[64]);
	X (new[22]);
	X (new[14]);
	X (new[73]);
	X (new[41]);
	X (new[38]);
	X (new[52]);
	X (new[121]);
	X (new[101]);
	X (new[55]);
	X (new[60]);
	X (new[8]);
	X (new[33]);
	X (new[118]);
	X (new[97]);
	X (new[40]);
	X (new[19]);
	X (new[92]);
	X (new[105]);
	X (new[54]);
	X (new[126]);
	X (new[109]);
	X (new[117]);
	X (new[116]);
	// Start computation
	qbit *nq0[42];
	qbit *nq1[42];
	qbit *nq2[42];
	nq0[0] = new[96];
	nq0[1] = new[34];
	nq0[2] = new[91];
	nq0[3] = new[3];
	nq0[4] = new[72];
	nq0[5] = new[84];
	nq0[6] = new[21];
	nq0[7] = new[112];
	nq0[8] = new[4];
	nq0[9] = new[49];
	nq0[10] = new[119];
	nq0[11] = new[46];
	nq0[12] = new[111];
	nq0[13] = new[40];
	nq0[14] = new[27];
	nq0[15] = new[67];
	nq0[16] = new[57];
	nq0[17] = new[36];
	nq0[18] = new[86];
	nq0[19] = new[64];
	nq0[20] = new[115];
	nq0[21] = new[18];
	nq0[22] = new[126];
	nq0[23] = new[17];
	nq0[24] = new[2];
	nq0[25] = new[50];
	nq0[26] = new[15];
	nq0[27] = new[116];
	nq0[28] = new[22];
	nq0[29] = new[63];
	nq0[30] = new[54];
	nq0[31] = new[53];
	nq0[32] = new[117];
	nq0[33] = new[92];
	nq0[34] = new[104];
	nq0[35] = new[26];
	nq0[36] = new[65];
	nq0[37] = new[106];
	nq0[38] = new[1];
	nq0[39] = new[24];
	nq0[40] = new[5];
	nq0[41] = new[35];
	nq1[0] = new[6];
	nq1[1] = new[14];
	nq1[2] = new[43];
	nq1[3] = new[95];
	nq1[4] = new[98];
	nq1[5] = new[108];
	nq1[6] = new[107];
	nq1[7] = new[120];
	nq1[8] = new[8];
	nq1[9] = new[73];
	nq1[10] = new[11];
	nq1[11] = new[88];
	nq1[12] = new[77];
	nq1[13] = new[81];
	nq1[14] = new[127];
	nq1[15] = new[71];
	nq1[16] = new[47];
	nq1[17] = new[118];
	nq1[18] = new[110];
	nq1[19] = new[44];
	nq1[20] = new[30];
	nq1[21] = new[123];
	nq1[22] = new[90];
	nq1[23] = new[25];
	nq1[24] = new[70];
	nq1[25] = new[94];
	nq1[26] = new[39];
	nq1[27] = new[31];
	nq1[28] = new[69];
	nq1[29] = new[125];
	nq1[30] = new[0];
	nq1[31] = new[7];
	nq1[32] = new[121];
	nq1[33] = new[37];
	nq1[34] = new[68];
	nq1[35] = new[80];
	nq1[36] = new[13];
	nq1[37] = new[75];
	nq1[38] = new[114];
	nq1[39] = new[105];
	nq1[40] = new[60];
	nq1[41] = new[16];
	nq2[0] = new[100];
	nq2[1] = new[32];
	nq2[2] = new[58];
	nq2[3] = new[9];
	nq2[4] = new[20];
	nq2[5] = new[28];
	nq2[6] = new[83];
	nq2[7] = new[66];
	nq2[8] = new[61];
	nq2[9] = new[38];
	nq2[10] = new[103];
	nq2[11] = new[82];
	nq2[12] = new[74];
	nq2[13] = new[76];
	nq2[14] = new[41];
	nq2[15] = new[19];
	nq2[16] = new[101];
	nq2[17] = new[59];
	nq2[18] = new[10];
	nq2[19] = new[52];
	nq2[20] = new[102];
	nq2[21] = new[51];
	nq2[22] = new[48];
	nq2[23] = new[78];
	nq2[24] = new[93];
	nq2[25] = new[29];
	nq2[26] = new[33];
	nq2[27] = new[45];
	nq2[28] = new[99];
	nq2[29] = new[42];
	nq2[30] = new[109];
	nq2[31] = new[23];
	nq2[32] = new[122];
	nq2[33] = new[56];
	nq2[34] = new[79];
	nq2[35] = new[89];
	nq2[36] = new[113];
	nq2[37] = new[62];
	nq2[38] = new[97];
	nq2[39] = new[87];
	nq2[40] = new[55];
	nq2[41] = new[85];
	for (int i = 0; i < LOOP; i++) {
		func1(nq0, 42);
		func2(nq1, 42);
		func3(nq2, 42);
	}
	return 0;
}
